"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DEFAULT_ADDRESS: () => DEFAULT_ADDRESS,
  DEFAULT_FUNDER: () => DEFAULT_FUNDER,
  DEFAULT_SLIPPAGE_TOLERANCE_BPS: () => DEFAULT_SLIPPAGE_TOLERANCE_BPS,
  DEFAULT_SOL_WRAPPING_STRATEGY: () => DEFAULT_SOL_WRAPPING_STRATEGY,
  DEFAULT_WHIRLPOOLS_CONFIG_ADDRESS: () => DEFAULT_WHIRLPOOLS_CONFIG_ADDRESS,
  DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS: () => DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  FUNDER: () => FUNDER,
  SLIPPAGE_TOLERANCE_BPS: () => SLIPPAGE_TOLERANCE_BPS,
  SOL_WRAPPING_STRATEGY: () => SOL_WRAPPING_STRATEGY,
  SPLASH_POOL_TICK_SPACING: () => SPLASH_POOL_TICK_SPACING,
  WHIRLPOOLS_CONFIG_ADDRESS: () => WHIRLPOOLS_CONFIG_ADDRESS,
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS: () => WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  closePositionInstructions: () => closePositionInstructions,
  createConcentratedLiquidityPoolInstructions: () => createConcentratedLiquidityPoolInstructions,
  createSplashPoolInstructions: () => createSplashPoolInstructions,
  decreaseLiquidityInstructions: () => decreaseLiquidityInstructions,
  fetchConcentratedLiquidityPool: () => fetchConcentratedLiquidityPool,
  fetchPositionsForOwner: () => fetchPositionsForOwner,
  fetchSplashPool: () => fetchSplashPool,
  fetchWhirlpools: () => fetchWhirlpools,
  harvestPositionInstructions: () => harvestPositionInstructions,
  increaseLiquidityInstructions: () => increaseLiquidityInstructions,
  openFullRangePositionInstructions: () => openFullRangePositionInstructions,
  openPositionInstructions: () => openPositionInstructions,
  resetConfiguration: () => resetConfiguration,
  setDefaultFunder: () => setDefaultFunder,
  setDefaultSlippageToleranceBps: () => setDefaultSlippageToleranceBps,
  setSolWrappingStrategy: () => setSolWrappingStrategy,
  setWhirlpoolsConfig: () => setWhirlpoolsConfig,
  swapInstructions: () => swapInstructions
});
module.exports = __toCommonJS(src_exports);

// src/config.ts
var import_whirlpools_client = require("@orca-so/whirlpools-client");
var import_web3 = require("@solana/web3.js");
var DEFAULT_ADDRESS = (0, import_web3.address)("11111111111111111111111111111111");
var DEFAULT_WHIRLPOOLS_CONFIG_ADDRESS = (0, import_web3.address)(
  "2LecshUwdy9xi7meFgHtFJQNSKk4KdTrcpvaB56dP2NQ"
);
var DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = (0, import_web3.address)(
  "777H5H3Tp9U11uRVRzFwM8BinfiakbaLT8vQpeuhvEiH"
);
var WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESS;
var WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;
async function setWhirlpoolsConfig(whirlpoolsConfigAddress) {
  WHIRLPOOLS_CONFIG_ADDRESS = whirlpoolsConfigAddress;
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = await (0, import_whirlpools_client.getWhirlpoolsConfigExtensionAddress)(whirlpoolsConfigAddress).then(
    (x) => x[0]
  );
}
var SPLASH_POOL_TICK_SPACING = 32896;
var DEFAULT_FUNDER = (0, import_web3.createNoopSigner)(DEFAULT_ADDRESS);
var FUNDER = DEFAULT_FUNDER;
function setDefaultFunder(funder) {
  if (typeof funder === "string") {
    FUNDER = (0, import_web3.createNoopSigner)(funder);
  } else {
    FUNDER = funder ?? (0, import_web3.createNoopSigner)(DEFAULT_ADDRESS);
  }
}
var DEFAULT_SLIPPAGE_TOLERANCE_BPS = 100;
var SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;
function setDefaultSlippageToleranceBps(slippageToleranceBps) {
  SLIPPAGE_TOLERANCE_BPS = Math.floor(slippageToleranceBps);
}
var DEFAULT_SOL_WRAPPING_STRATEGY = "keypair";
var SOL_WRAPPING_STRATEGY = DEFAULT_SOL_WRAPPING_STRATEGY;
function setSolWrappingStrategy(strategy) {
  SOL_WRAPPING_STRATEGY = strategy;
}
function resetConfiguration() {
  WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESS;
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;
  FUNDER = DEFAULT_FUNDER;
  SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;
  SOL_WRAPPING_STRATEGY = DEFAULT_SOL_WRAPPING_STRATEGY;
}

// src/createPool.ts
var import_whirlpools_client2 = require("@orca-so/whirlpools-client");
var import_web32 = require("@solana/web3.js");
var import_whirlpools_core = require("@orca-so/whirlpools-core");
var import_token = require("@solana-program/token");
var import_assert = __toESM(require("assert"), 1);
function createSplashPoolInstructions(rpc, tokenMintA, tokenMintB, initialPrice = 1, funder = FUNDER) {
  return createConcentratedLiquidityPoolInstructions(
    rpc,
    tokenMintA,
    tokenMintB,
    SPLASH_POOL_TICK_SPACING,
    initialPrice,
    funder
  );
}
async function createConcentratedLiquidityPoolInstructions(rpc, tokenMintA, tokenMintB, tickSpacing, initialPrice = 1, funder = FUNDER) {
  (0, import_assert.default)(
    funder.address !== DEFAULT_ADDRESS,
    "Either supply a funder or set the default funder"
  );
  (0, import_assert.default)(
    Buffer.from(tokenMintA) < Buffer.from(tokenMintB),
    "Token order needs to be flipped to match the canonical ordering (i.e. sorted on the byte repr. of the mint pubkeys)"
  );
  const instructions = [];
  let stateSpace = 0;
  const [mintA, mintB] = await (0, import_token.fetchAllMint)(rpc, [tokenMintA, tokenMintB]);
  const decimalsA = mintA.data.decimals;
  const decimalsB = mintB.data.decimals;
  const tokenProgramA = mintA.programAddress;
  const tokenProgramB = mintB.programAddress;
  const initialSqrtPrice = (0, import_whirlpools_core.priceToSqrtPrice)(initialPrice, decimalsA, decimalsB);
  const [
    poolAddress,
    feeTier,
    tokenBadgeA,
    tokenBadgeB,
    tokenVaultA,
    tokenVaultB
  ] = await Promise.all([
    (0, import_whirlpools_client2.getWhirlpoolAddress)(
      WHIRLPOOLS_CONFIG_ADDRESS,
      tokenMintA,
      tokenMintB,
      tickSpacing
    ).then((x) => x[0]),
    (0, import_whirlpools_client2.getFeeTierAddress)(WHIRLPOOLS_CONFIG_ADDRESS, tickSpacing).then((x) => x[0]),
    (0, import_whirlpools_client2.getTokenBadgeAddress)(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintA).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client2.getTokenBadgeAddress)(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintB).then(
      (x) => x[0]
    ),
    (0, import_web32.generateKeyPairSigner)(),
    (0, import_web32.generateKeyPairSigner)()
  ]);
  instructions.push(
    (0, import_whirlpools_client2.getInitializePoolV2Instruction)({
      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
      tokenMintA,
      tokenMintB,
      tokenBadgeA,
      tokenBadgeB,
      funder,
      whirlpool: poolAddress,
      tokenVaultA,
      tokenVaultB,
      tokenProgramA,
      tokenProgramB,
      feeTier,
      tickSpacing,
      initialSqrtPrice
    })
  );
  stateSpace += (0, import_token.getTokenSize)() * 2;
  stateSpace += (0, import_whirlpools_client2.getWhirlpoolSize)();
  const fullRange = (0, import_whirlpools_core.getFullRangeTickIndexes)(tickSpacing);
  const lowerTickIndex = (0, import_whirlpools_core.getTickArrayStartTickIndex)(
    fullRange.tickLowerIndex,
    tickSpacing
  );
  const upperTickIndex = (0, import_whirlpools_core.getTickArrayStartTickIndex)(
    fullRange.tickUpperIndex,
    tickSpacing
  );
  const initialTickIndex = (0, import_whirlpools_core.sqrtPriceToTickIndex)(initialSqrtPrice);
  const currentTickIndex = (0, import_whirlpools_core.getTickArrayStartTickIndex)(
    initialTickIndex,
    tickSpacing
  );
  const tickArrayIndexes = Array.from(
    /* @__PURE__ */ new Set([lowerTickIndex, upperTickIndex, currentTickIndex])
  );
  const tickArrayAddresses = await Promise.all(
    tickArrayIndexes.map(
      (x) => (0, import_whirlpools_client2.getTickArrayAddress)(poolAddress, x).then((x2) => x2[0])
    )
  );
  for (let i = 0; i < tickArrayIndexes.length; i++) {
    instructions.push(
      (0, import_whirlpools_client2.getInitializeTickArrayInstruction)({
        whirlpool: poolAddress,
        funder,
        tickArray: tickArrayAddresses[i],
        startTickIndex: tickArrayIndexes[i]
      })
    );
    stateSpace += (0, import_whirlpools_client2.getTickArraySize)();
  }
  const nonRefundableRent = await rpc.getMinimumBalanceForRentExemption(BigInt(stateSpace)).send();
  return {
    instructions,
    poolAddress,
    estInitializationCost: nonRefundableRent
  };
}

// src/decreaseLiquidity.ts
var import_whirlpools_client3 = require("@orca-so/whirlpools-client");
var import_whirlpools_core2 = require("@orca-so/whirlpools-core");
var import_token3 = require("@solana-program/token");

// src/token.ts
var import_token2 = require("@solana-program/token");
var import_web33 = require("@solana/web3.js");
var import_system = require("@solana-program/system");
var NATIVE_MINT = (0, import_web33.address)(
  "So11111111111111111111111111111111111111112"
);
function mintFilter(x) {
  if (SOL_WRAPPING_STRATEGY === "none" || SOL_WRAPPING_STRATEGY === "ata") {
    return true;
  }
  return x != NATIVE_MINT;
}
async function prepareTokenAccountsInstructions(rpc, owner, spec) {
  const mintAddresses = Array.isArray(spec) ? spec : Object.keys(spec);
  const solMintIndex = mintAddresses.indexOf(NATIVE_MINT);
  const hasSolMint = solMintIndex !== -1;
  const mints = await (0, import_token2.fetchAllMint)(rpc, mintAddresses.filter(mintFilter));
  const tokenAddresses = await Promise.all(
    mints.map(
      (mint) => (0, import_token2.findAssociatedTokenPda)({
        owner: owner.address,
        mint: mint.address,
        tokenProgram: mint.programAddress
      }).then((x) => x[0])
    )
  );
  const tokenAccounts = await (0, import_token2.fetchAllMaybeToken)(rpc, tokenAddresses);
  const tokenAccountAddresses = {};
  const createInstructions = [];
  const cleanupInstructions = [];
  for (let i = 0; i < mints.length; i++) {
    const mint = mints[i];
    const tokenAccount = tokenAccounts[i];
    tokenAccountAddresses[mint.address] = tokenAccount.address;
    if (tokenAccount.exists) {
      continue;
    }
    createInstructions.push(
      (0, import_token2.getCreateAssociatedTokenInstruction)({
        payer: owner,
        owner: owner.address,
        ata: tokenAccount.address,
        mint: mint.address,
        tokenProgram: mint.programAddress
      })
    );
  }
  if (hasSolMint && SOL_WRAPPING_STRATEGY === "keypair") {
    const keypair = await (0, import_web33.generateKeyPairSigner)();
    const space = (0, import_token2.getTokenSize)();
    const lamports3 = await rpc.getMinimumBalanceForRentExemption(BigInt(space)).send();
    createInstructions.push(
      (0, import_system.getCreateAccountInstruction)({
        payer: owner,
        newAccount: keypair,
        lamports: lamports3,
        space,
        programAddress: import_token2.TOKEN_PROGRAM_ADDRESS
      }),
      (0, import_token2.getInitializeAccount3Instruction)({
        account: keypair.address,
        mint: NATIVE_MINT,
        owner: owner.address
      })
    );
    cleanupInstructions.push(
      (0, import_token2.getCloseAccountInstruction)({
        account: keypair.address,
        owner,
        destination: owner.address
      })
    );
    tokenAccountAddresses[NATIVE_MINT] = keypair.address;
  }
  if (hasSolMint && SOL_WRAPPING_STRATEGY === "seed") {
    const space = (0, import_token2.getTokenSize)();
    const amount = await rpc.getMinimumBalanceForRentExemption(BigInt(space)).send();
    const seed = Date.now().toString();
    const buffer = await crypto.subtle.digest(
      "SHA-256",
      Buffer.concat([
        Buffer.from((0, import_web33.getAddressEncoder)().encode(owner.address)),
        Buffer.from(seed),
        Buffer.from((0, import_web33.getAddressEncoder)().encode(import_token2.TOKEN_PROGRAM_ADDRESS))
      ])
    );
    tokenAccountAddresses[NATIVE_MINT] = (0, import_web33.getAddressDecoder)().decode(
      new Uint8Array(buffer)
    );
    createInstructions.push(
      (0, import_system.getCreateAccountWithSeedInstruction)({
        payer: owner,
        newAccount: tokenAccountAddresses[NATIVE_MINT],
        base: owner.address,
        baseAccount: owner,
        seed,
        space,
        amount,
        programAddress: import_token2.TOKEN_PROGRAM_ADDRESS
      }),
      (0, import_token2.getInitializeAccount3Instruction)({
        account: tokenAccountAddresses[NATIVE_MINT],
        mint: NATIVE_MINT,
        owner: owner.address
      })
    );
    cleanupInstructions.push(
      (0, import_token2.getCloseAccountInstruction)({
        account: tokenAccountAddresses[NATIVE_MINT],
        owner,
        destination: owner.address
      })
    );
  }
  if (hasSolMint && SOL_WRAPPING_STRATEGY === "ata") {
    const account = tokenAccounts[solMintIndex];
    if (!account.exists) {
      cleanupInstructions.push(
        (0, import_token2.getCloseAccountInstruction)({
          account: account.address,
          owner,
          destination: owner.address
        })
      );
    }
  }
  if (hasSolMint && !Array.isArray(spec) && spec[NATIVE_MINT] > 0 && SOL_WRAPPING_STRATEGY !== "none") {
    createInstructions.push(
      (0, import_system.getTransferSolInstruction)({
        source: owner,
        destination: tokenAccountAddresses[NATIVE_MINT],
        amount: spec[NATIVE_MINT]
      }),
      (0, import_token2.getSyncNativeInstruction)({
        account: tokenAccountAddresses[NATIVE_MINT]
      })
    );
  }
  return {
    createInstructions,
    cleanupInstructions,
    tokenAccountAddresses
  };
}
function getCurrentTransferFee(mint, currentEpoch) {
  if (mint == null || "exists" in mint && !mint.exists || mint.data.extensions.__option === "None") {
    return void 0;
  }
  const feeConfig = mint.data.extensions.value.find(
    (x) => x.__kind === "TransferFeeConfig"
  );
  if (feeConfig == null) {
    return void 0;
  }
  const transferFee = currentEpoch >= feeConfig.newerTransferFee.epoch ? feeConfig.newerTransferFee : feeConfig.olderTransferFee;
  return {
    feeBps: transferFee.transferFeeBasisPoints,
    maxFee: transferFee.maximumFee
  };
}

// src/decreaseLiquidity.ts
var import_token_2022 = require("@solana-program/token-2022");
var import_memo = require("@solana-program/memo");
var import_assert2 = __toESM(require("assert"), 1);
function getDecreaseLiquidityQuote(param, pool, tickRange, slippageToleranceBps, transferFeeA, transferFeeB) {
  if ("liquidity" in param) {
    return (0, import_whirlpools_core2.decreaseLiquidityQuote)(
      param.liquidity,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else if ("tokenA" in param) {
    return (0, import_whirlpools_core2.decreaseLiquidityQuoteA)(
      param.tokenA,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else {
    return (0, import_whirlpools_core2.decreaseLiquidityQuoteB)(
      param.tokenB,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  }
}
async function decreaseLiquidityInstructions(rpc, positionMintAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  (0, import_assert2.default)(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply the authority or set the default funder"
  );
  const positionAddress = await (0, import_whirlpools_client3.getPositionAddress)(positionMintAddress);
  const position = await (0, import_whirlpools_client3.fetchPosition)(rpc, positionAddress[0]);
  const whirlpool = await (0, import_whirlpools_client3.fetchWhirlpool)(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint] = await (0, import_token_2022.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB,
    positionMintAddress
  ]);
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getDecreaseLiquidityQuote(
    param,
    whirlpool.data,
    position.data,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const instructions = [];
  const lowerTickArrayStartIndex = (0, import_whirlpools_core2.getTickArrayStartTickIndex)(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = (0, import_whirlpools_core2.getTickArrayStartTickIndex)(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, tickArrayLower, tickArrayUpper] = await Promise.all([
    (0, import_token3.findAssociatedTokenPda)({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    (0, import_whirlpools_client3.getTickArrayAddress)(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client3.getTickArrayAddress)(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  instructions.push(...createInstructions);
  instructions.push(
    (0, import_whirlpools_client3.getDecreaseLiquidityV2Instruction)({
      whirlpool: whirlpool.address,
      positionAuthority: authority,
      position: position.address,
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      memoProgram: import_memo.MEMO_PROGRAM_ADDRESS,
      tickArrayLower,
      tickArrayUpper,
      liquidityAmount: quote.liquidityDelta,
      tokenMinA: quote.tokenMinA,
      tokenMinB: quote.tokenMinB,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  return { quote, instructions };
}
async function closePositionInstructions(rpc, positionMintAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  (0, import_assert2.default)(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply an authority or set the default funder"
  );
  const positionAddress = await (0, import_whirlpools_client3.getPositionAddress)(positionMintAddress);
  const position = await (0, import_whirlpools_client3.fetchPosition)(rpc, positionAddress[0]);
  const whirlpool = await (0, import_whirlpools_client3.fetchWhirlpool)(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint, ...rewardMints] = await (0, import_token_2022.fetchAllMaybeMint)(
    rpc,
    [
      whirlpool.data.tokenMintA,
      whirlpool.data.tokenMintB,
      positionMintAddress,
      ...whirlpool.data.rewardInfos.map((x) => x.mint).filter((x) => x !== DEFAULT_ADDRESS)
    ]
  );
  (0, import_assert2.default)(mintA.exists, "Token A not found");
  (0, import_assert2.default)(mintB.exists, "Token B not found");
  (0, import_assert2.default)(positionMint.exists, "Position mint not found");
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getDecreaseLiquidityQuote(
    param,
    whirlpool.data,
    position.data,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const lowerTickArrayStartIndex = (0, import_whirlpools_core2.getTickArrayStartTickIndex)(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = (0, import_whirlpools_core2.getTickArrayStartTickIndex)(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] = await Promise.all([
    (0, import_token3.findAssociatedTokenPda)({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    (0, import_whirlpools_client3.getTickArrayAddress)(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client3.getTickArrayAddress)(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const [lowerTickArray, upperTickArray] = await (0, import_whirlpools_client3.fetchAllTickArray)(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  const lowerTick = lowerTickArray.data.ticks[(0, import_whirlpools_core2.getTickIndexInArray)(
    position.data.tickLowerIndex,
    lowerTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const upperTick = upperTickArray.data.ticks[(0, import_whirlpools_core2.getTickIndexInArray)(
    position.data.tickUpperIndex,
    upperTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const feesQuote = (0, import_whirlpools_core2.collectFeesQuote)(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    transferFeeA,
    transferFeeB
  );
  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1e3));
  const rewardsQuote = (0, import_whirlpools_core2.collectRewardsQuote)(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    currentUnixTimestamp,
    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch)
  );
  const requiredMints = [];
  if (quote.liquidityDelta > 0n || feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    requiredMints.push(whirlpool.data.tokenMintA);
    requiredMints.push(whirlpool.data.tokenMintB);
  }
  if (rewardsQuote.rewards[0].rewardsOwed > 0n) {
    requiredMints.push(whirlpool.data.rewardInfos[0].mint);
  }
  if (rewardsQuote.rewards[1].rewardsOwed > 0n) {
    requiredMints.push(whirlpool.data.rewardInfos[1].mint);
  }
  if (rewardsQuote.rewards[2].rewardsOwed > 0n) {
    requiredMints.push(whirlpool.data.rewardInfos[2].mint);
  }
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, requiredMints);
  const instructions = [];
  instructions.push(...createInstructions);
  if (position.data.liquidity > 0n) {
    instructions.push(
      (0, import_whirlpools_client3.getUpdateFeesAndRewardsInstruction)({
        whirlpool: whirlpool.address,
        position: positionAddress[0],
        tickArrayLower: lowerTickArrayAddress,
        tickArrayUpper: upperTickArrayAddress
      })
    );
  }
  if (quote.liquidityDelta > 0n) {
    instructions.push(
      (0, import_whirlpools_client3.getDecreaseLiquidityV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tickArrayLower: lowerTickArrayAddress,
        tickArrayUpper: upperTickArrayAddress,
        liquidityAmount: quote.liquidityDelta,
        tokenMinA: quote.tokenMinA,
        tokenMinB: quote.tokenMinB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: import_memo.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    instructions.push(
      (0, import_whirlpools_client3.getCollectFeesV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: import_memo.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {
      continue;
    }
    const rewardMint = rewardMints[i];
    (0, import_assert2.default)(rewardMint.exists, `Reward mint ${i} not found`);
    instructions.push(
      (0, import_whirlpools_client3.getCollectRewardV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],
        rewardVault: whirlpool.data.rewardInfos[i].vault,
        rewardIndex: i,
        rewardMint: rewardMint.address,
        rewardTokenProgram: rewardMint.programAddress,
        memoProgram: import_memo.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  switch (positionMint.programAddress) {
    case import_token3.TOKEN_PROGRAM_ADDRESS:
      instructions.push(
        (0, import_whirlpools_client3.getClosePositionInstruction)({
          positionAuthority: authority,
          position: positionAddress[0],
          positionTokenAccount,
          positionMint: positionMintAddress,
          receiver: authority.address
        })
      );
      break;
    case import_token_2022.TOKEN_2022_PROGRAM_ADDRESS:
      instructions.push(
        (0, import_whirlpools_client3.getClosePositionWithTokenExtensionsInstruction)({
          positionAuthority: authority,
          position: positionAddress[0],
          positionTokenAccount,
          positionMint: positionMintAddress,
          receiver: authority.address,
          token2022Program: import_token_2022.TOKEN_2022_PROGRAM_ADDRESS
        })
      );
      break;
    default:
      throw new Error("Invalid token program");
  }
  instructions.push(...cleanupInstructions);
  return {
    instructions,
    quote,
    feesQuote,
    rewardsQuote
  };
}

// src/harvest.ts
var import_whirlpools_core3 = require("@orca-so/whirlpools-core");
var import_whirlpools_client4 = require("@orca-so/whirlpools-client");
var import_token5 = require("@solana-program/token");
var import_token_20222 = require("@solana-program/token-2022");
var import_memo2 = require("@solana-program/memo");
var import_assert3 = __toESM(require("assert"), 1);
async function harvestPositionInstructions(rpc, positionMintAddress, authority = FUNDER) {
  (0, import_assert3.default)(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply an authority or set the default funder"
  );
  const currentEpoch = await rpc.getEpochInfo().send();
  const positionAddress = await (0, import_whirlpools_client4.getPositionAddress)(positionMintAddress);
  const position = await (0, import_whirlpools_client4.fetchPosition)(rpc, positionAddress[0]);
  const whirlpool = await (0, import_whirlpools_client4.fetchWhirlpool)(rpc, position.data.whirlpool);
  const [mintA, mintB, positionMint, ...rewardMints] = await (0, import_token_20222.fetchAllMaybeMint)(
    rpc,
    [
      whirlpool.data.tokenMintA,
      whirlpool.data.tokenMintB,
      positionMintAddress,
      ...whirlpool.data.rewardInfos.map((x) => x.mint).filter((x) => x !== DEFAULT_ADDRESS)
    ]
  );
  (0, import_assert3.default)(mintA.exists, "Token A not found");
  (0, import_assert3.default)(mintB.exists, "Token B not found");
  (0, import_assert3.default)(positionMint.exists, "Position mint not found");
  const lowerTickArrayStartIndex = (0, import_whirlpools_core3.getTickArrayStartTickIndex)(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = (0, import_whirlpools_core3.getTickArrayStartTickIndex)(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] = await Promise.all([
    (0, import_token5.findAssociatedTokenPda)({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    (0, import_whirlpools_client4.getTickArrayAddress)(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client4.getTickArrayAddress)(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const [lowerTickArray, upperTickArray] = await (0, import_whirlpools_client4.fetchAllTickArray)(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  const lowerTick = lowerTickArray.data.ticks[(0, import_whirlpools_core3.getTickIndexInArray)(
    position.data.tickLowerIndex,
    lowerTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const upperTick = upperTickArray.data.ticks[(0, import_whirlpools_core3.getTickIndexInArray)(
    position.data.tickUpperIndex,
    upperTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const feesQuote = (0, import_whirlpools_core3.collectFeesQuote)(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    getCurrentTransferFee(mintA, currentEpoch.epoch),
    getCurrentTransferFee(mintB, currentEpoch.epoch)
  );
  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1e3));
  const rewardsQuote = (0, import_whirlpools_core3.collectRewardsQuote)(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    currentUnixTimestamp,
    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch)
  );
  const requiredMints = [];
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    requiredMints.push(whirlpool.data.tokenMintA);
    requiredMints.push(whirlpool.data.tokenMintB);
  }
  if (rewardsQuote.rewards[0].rewardsOwed > 0n) {
    requiredMints.push(whirlpool.data.rewardInfos[0].mint);
  }
  if (rewardsQuote.rewards[1].rewardsOwed > 0n) {
    requiredMints.push(whirlpool.data.rewardInfos[1].mint);
  }
  if (rewardsQuote.rewards[2].rewardsOwed > 0n) {
    requiredMints.push(whirlpool.data.rewardInfos[2].mint);
  }
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, requiredMints);
  const instructions = [];
  instructions.push(...createInstructions);
  if (position.data.liquidity > 0n) {
    instructions.push(
      (0, import_whirlpools_client4.getUpdateFeesAndRewardsInstruction)({
        whirlpool: whirlpool.address,
        position: positionAddress[0],
        tickArrayLower: lowerTickArrayAddress,
        tickArrayUpper: upperTickArrayAddress
      })
    );
  }
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    instructions.push(
      (0, import_whirlpools_client4.getCollectFeesV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: import_memo2.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {
      continue;
    }
    const rewardMint = rewardMints[i];
    (0, import_assert3.default)(rewardMint.exists, `Reward mint ${i} not found`);
    instructions.push(
      (0, import_whirlpools_client4.getCollectRewardV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],
        rewardVault: whirlpool.data.rewardInfos[i].vault,
        rewardIndex: i,
        rewardMint: rewardMint.address,
        rewardTokenProgram: rewardMint.programAddress,
        memoProgram: import_memo2.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  instructions.push(...cleanupInstructions);
  return {
    feesQuote,
    rewardsQuote,
    instructions
  };
}

// src/increaseLiquidity.ts
var import_whirlpools_client5 = require("@orca-so/whirlpools-client");
var import_whirlpools_core4 = require("@orca-so/whirlpools-core");
var import_web34 = require("@solana/web3.js");
var import_token7 = require("@solana-program/token");
var import_token_20223 = require("@solana-program/token-2022");
var import_memo3 = require("@solana-program/memo");
var import_assert4 = __toESM(require("assert"), 1);
function getIncreaseLiquidityQuote(param, pool, tickRange, slippageToleranceBps, transferFeeA, transferFeeB) {
  if ("liquidity" in param) {
    return (0, import_whirlpools_core4.increaseLiquidityQuote)(
      param.liquidity,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else if ("tokenA" in param) {
    return (0, import_whirlpools_core4.increaseLiquidityQuoteA)(
      param.tokenA,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else {
    return (0, import_whirlpools_core4.increaseLiquidityQuoteB)(
      param.tokenB,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  }
}
async function increaseLiquidityInstructions(rpc, positionMintAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  (0, import_assert4.default)(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply the authority or set the default funder"
  );
  const positionAddress = await (0, import_whirlpools_client5.getPositionAddress)(positionMintAddress);
  const position = await (0, import_whirlpools_client5.fetchPosition)(rpc, positionAddress[0]);
  const whirlpool = await (0, import_whirlpools_client5.fetchWhirlpool)(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint] = await (0, import_token_20223.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB,
    positionMintAddress
  ]);
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getIncreaseLiquidityQuote(
    param,
    whirlpool.data,
    position.data,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const instructions = [];
  const lowerTickArrayStartIndex = (0, import_whirlpools_core4.getTickArrayStartTickIndex)(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = (0, import_whirlpools_core4.getTickArrayStartTickIndex)(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, tickArrayLower, tickArrayUpper] = await Promise.all([
    (0, import_token7.findAssociatedTokenPda)({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    (0, import_whirlpools_client5.getTickArrayAddress)(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client5.getTickArrayAddress)(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, {
    [whirlpool.data.tokenMintA]: quote.tokenMaxA,
    [whirlpool.data.tokenMintB]: quote.tokenMaxB
  });
  instructions.push(...createInstructions);
  instructions.push(
    (0, import_whirlpools_client5.getIncreaseLiquidityV2Instruction)({
      whirlpool: whirlpool.address,
      positionAuthority: authority,
      position: position.address,
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      tickArrayLower,
      tickArrayUpper,
      liquidityAmount: quote.liquidityDelta,
      tokenMaxA: quote.tokenMaxA,
      tokenMaxB: quote.tokenMaxB,
      memoProgram: import_memo3.MEMO_PROGRAM_ADDRESS,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  return {
    quote,
    instructions,
    positionMint: positionMintAddress,
    initializationCost: (0, import_web34.lamports)(0n)
  };
}
async function internalOpenPositionInstructions(rpc, whirlpool, param, lowerTickIndex, upperTickIndex, mintA, mintB, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  (0, import_assert4.default)(
    funder.address !== DEFAULT_ADDRESS,
    "Either supply a funder or set the default funder"
  );
  const instructions = [];
  let nonReclaimableStateSpace = 0;
  const initializableLowerTickIndex = (0, import_whirlpools_core4.getInitializableTickIndex)(
    lowerTickIndex,
    whirlpool.data.tickSpacing,
    false
  );
  const initializableUpperTickIndex = (0, import_whirlpools_core4.getInitializableTickIndex)(
    upperTickIndex,
    whirlpool.data.tickSpacing,
    true
  );
  const tickRange = (0, import_whirlpools_core4.orderTickIndexes)(
    initializableLowerTickIndex,
    initializableUpperTickIndex
  );
  const currentEpoch = await rpc.getEpochInfo().send();
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getIncreaseLiquidityQuote(
    param,
    whirlpool.data,
    tickRange,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const positionMint = await (0, import_web34.generateKeyPairSigner)();
  const lowerTickArrayIndex = (0, import_whirlpools_core4.getTickArrayStartTickIndex)(
    tickRange.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayIndex = (0, import_whirlpools_core4.getTickArrayStartTickIndex)(
    tickRange.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [
    positionAddress,
    positionTokenAccount,
    lowerTickArrayAddress,
    upperTickArrayAddress
  ] = await Promise.all([
    (0, import_whirlpools_client5.getPositionAddress)(positionMint.address),
    (0, import_token7.findAssociatedTokenPda)({
      owner: funder.address,
      mint: positionMint.address,
      tokenProgram: import_token_20223.TOKEN_2022_PROGRAM_ADDRESS
    }).then((x) => x[0]),
    (0, import_whirlpools_client5.getTickArrayAddress)(whirlpool.address, lowerTickArrayIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client5.getTickArrayAddress)(whirlpool.address, upperTickArrayIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, funder, {
    [whirlpool.data.tokenMintA]: quote.tokenMaxA,
    [whirlpool.data.tokenMintB]: quote.tokenMaxB
  });
  instructions.push(...createInstructions);
  const [lowerTickArray, upperTickArray] = await (0, import_whirlpools_client5.fetchAllMaybeTickArray)(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  if (!lowerTickArray.exists) {
    instructions.push(
      (0, import_whirlpools_client5.getInitializeTickArrayInstruction)({
        whirlpool: whirlpool.address,
        funder,
        tickArray: lowerTickArrayAddress,
        startTickIndex: lowerTickIndex
      })
    );
    nonReclaimableStateSpace += (0, import_whirlpools_client5.getTickArraySize)();
  }
  if (!upperTickArray.exists && lowerTickArrayIndex !== upperTickArrayIndex) {
    instructions.push(
      (0, import_whirlpools_client5.getInitializeTickArrayInstruction)({
        whirlpool: whirlpool.address,
        funder,
        tickArray: upperTickArrayAddress,
        startTickIndex: upperTickIndex
      })
    );
    nonReclaimableStateSpace += (0, import_whirlpools_client5.getTickArraySize)();
  }
  instructions.push(
    (0, import_whirlpools_client5.getOpenPositionWithTokenExtensionsInstruction)({
      funder,
      owner: funder.address,
      position: positionAddress[0],
      positionMint,
      positionTokenAccount,
      whirlpool: whirlpool.address,
      associatedTokenProgram: import_token7.ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
      tickLowerIndex: tickRange.tickLowerIndex,
      tickUpperIndex: tickRange.tickUpperIndex,
      token2022Program: import_token_20223.TOKEN_2022_PROGRAM_ADDRESS,
      metadataUpdateAuth: (0, import_web34.address)(
        "3axbTs2z5GBy6usVbNVoqEgZMng3vZvMnAoX29BFfwhr"
      ),
      withTokenMetadataExtension: true
    })
  );
  instructions.push(
    (0, import_whirlpools_client5.getIncreaseLiquidityV2Instruction)({
      whirlpool: whirlpool.address,
      positionAuthority: funder,
      position: positionAddress[0],
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      tickArrayLower: lowerTickArrayAddress,
      tickArrayUpper: upperTickArrayAddress,
      liquidityAmount: quote.liquidityDelta,
      tokenMaxA: quote.tokenMaxA,
      tokenMaxB: quote.tokenMaxB,
      memoProgram: import_memo3.MEMO_PROGRAM_ADDRESS,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  let nonRefundableRent = (0, import_web34.lamports)(0n);
  if (nonReclaimableStateSpace > 0) {
    nonRefundableRent = await rpc.getMinimumBalanceForRentExemption(BigInt(nonReclaimableStateSpace)).send();
  }
  return {
    instructions,
    quote,
    positionMint: positionMint.address,
    initializationCost: nonRefundableRent
  };
}
async function openFullRangePositionInstructions(rpc, poolAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  const whirlpool = await (0, import_whirlpools_client5.fetchWhirlpool)(rpc, poolAddress);
  const tickRange = (0, import_whirlpools_core4.getFullRangeTickIndexes)(whirlpool.data.tickSpacing);
  const [mintA, mintB] = await (0, import_token_20223.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  return internalOpenPositionInstructions(
    rpc,
    whirlpool,
    param,
    tickRange.tickLowerIndex,
    tickRange.tickUpperIndex,
    mintA,
    mintB,
    slippageToleranceBps,
    funder
  );
}
async function openPositionInstructions(rpc, poolAddress, param, lowerPrice, upperPrice, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  const whirlpool = await (0, import_whirlpools_client5.fetchWhirlpool)(rpc, poolAddress);
  (0, import_assert4.default)(
    whirlpool.data.tickSpacing !== SPLASH_POOL_TICK_SPACING,
    "Splash pools only support full range positions"
  );
  const [mintA, mintB] = await (0, import_token_20223.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  const decimalsA = mintA.data.decimals;
  const decimalsB = mintB.data.decimals;
  const lowerTickIndex = (0, import_whirlpools_core4.priceToTickIndex)(lowerPrice, decimalsA, decimalsB);
  const lowerInitializableTickIndex = (0, import_whirlpools_core4.getInitializableTickIndex)(
    lowerTickIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickIndex = (0, import_whirlpools_core4.priceToTickIndex)(upperPrice, decimalsA, decimalsB);
  const upperInitializableTickIndex = (0, import_whirlpools_core4.getInitializableTickIndex)(
    upperTickIndex,
    whirlpool.data.tickSpacing
  );
  return internalOpenPositionInstructions(
    rpc,
    whirlpool,
    param,
    lowerInitializableTickIndex,
    upperInitializableTickIndex,
    mintA,
    mintB,
    slippageToleranceBps,
    funder
  );
}

// src/pool.ts
var import_whirlpools_client6 = require("@orca-so/whirlpools-client");
async function fetchSplashPool(rpc, tokenMintOne, tokenMintTwo) {
  return fetchConcentratedLiquidityPool(
    rpc,
    tokenMintOne,
    tokenMintTwo,
    SPLASH_POOL_TICK_SPACING
  );
}
async function fetchConcentratedLiquidityPool(rpc, tokenMintOne, tokenMintTwo, tickSpacing) {
  const [tokenMintA, tokenMintB] = Buffer.from(tokenMintOne) < Buffer.from(tokenMintTwo) ? [tokenMintOne, tokenMintTwo] : [tokenMintTwo, tokenMintOne];
  const feeTierAddress = await (0, import_whirlpools_client6.getFeeTierAddress)(
    WHIRLPOOLS_CONFIG_ADDRESS,
    tickSpacing
  ).then((x) => x[0]);
  const poolAddress = await (0, import_whirlpools_client6.getWhirlpoolAddress)(
    WHIRLPOOLS_CONFIG_ADDRESS,
    tokenMintA,
    tokenMintB,
    tickSpacing
  ).then((x) => x[0]);
  const [configAccount, feeTierAccount, poolAccount] = await Promise.all([
    (0, import_whirlpools_client6.fetchWhirlpoolsConfig)(rpc, WHIRLPOOLS_CONFIG_ADDRESS),
    (0, import_whirlpools_client6.fetchFeeTier)(rpc, feeTierAddress),
    (0, import_whirlpools_client6.fetchMaybeWhirlpool)(rpc, poolAddress)
  ]);
  if (poolAccount.exists) {
    return {
      initialized: true,
      address: poolAddress,
      ...poolAccount.data
    };
  } else {
    return {
      initialized: false,
      address: poolAddress,
      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
      tickSpacing,
      feeRate: feeTierAccount.data.defaultFeeRate,
      protocolFeeRate: configAccount.data.defaultProtocolFeeRate,
      tokenMintA,
      tokenMintB
    };
  }
}
async function fetchWhirlpools(rpc, tokenMintOne, tokenMintTwo) {
  const [tokenMintA, tokenMintB] = Buffer.from(tokenMintOne) < Buffer.from(tokenMintTwo) ? [tokenMintOne, tokenMintTwo] : [tokenMintTwo, tokenMintOne];
  const feeTierAccounts = await (0, import_whirlpools_client6.fetchAllFeeTierWithFilter)(
    rpc,
    (0, import_whirlpools_client6.feeTierWhirlpoolsConfigFilter)(WHIRLPOOLS_CONFIG_ADDRESS)
  );
  const supportedTickSpacings = feeTierAccounts.map((x) => x.data.tickSpacing);
  const poolAddresses = await Promise.all(
    supportedTickSpacings.map(
      (x) => (0, import_whirlpools_client6.getWhirlpoolAddress)(
        WHIRLPOOLS_CONFIG_ADDRESS,
        tokenMintA,
        tokenMintB,
        x
      ).then((x2) => x2[0])
    )
  );
  const [configAccount, poolAccounts] = await Promise.all([
    (0, import_whirlpools_client6.fetchWhirlpoolsConfig)(rpc, WHIRLPOOLS_CONFIG_ADDRESS),
    (0, import_whirlpools_client6.fetchAllMaybeWhirlpool)(rpc, poolAddresses)
  ]);
  const pools = [];
  for (let i = 0; i < supportedTickSpacings.length; i++) {
    const tickSpacing = supportedTickSpacings[i];
    const feeTierAccount = feeTierAccounts[i];
    const poolAccount = poolAccounts[i];
    const poolAddress = poolAddresses[i];
    if (poolAccount.exists) {
      pools.push({
        initialized: true,
        address: poolAddress,
        ...poolAccount.data
      });
    } else {
      pools.push({
        initialized: false,
        address: poolAddress,
        whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
        tickSpacing,
        feeRate: feeTierAccount.data.defaultFeeRate,
        protocolFeeRate: configAccount.data.defaultProtocolFeeRate,
        tokenMintA,
        tokenMintB
      });
    }
  }
  return pools;
}

// src/position.ts
var import_whirlpools_client7 = require("@orca-so/whirlpools-client");
var import_whirlpools_core5 = require("@orca-so/whirlpools-core");
var import_token9 = require("@solana-program/token");
var import_token_20224 = require("@solana-program/token-2022");
var import_web35 = require("@solana/web3.js");
function getPositionInBundleAddresses(positionBundle) {
  const buffer = Buffer.from(positionBundle.positionBitmap);
  const positions = [];
  for (let i = 0; i < (0, import_whirlpools_core5._POSITION_BUNDLE_SIZE)(); i++) {
    const byteIndex = Math.floor(i / 8);
    const bitIndex = i % 8;
    if (buffer[byteIndex] & 1 << bitIndex) {
      positions.push(
        (0, import_whirlpools_client7.getBundledPositionAddress)(positionBundle.positionBundleMint, i).then(
          (x) => x[0]
        )
      );
    }
  }
  return positions;
}
async function fetchPositionsForOwner(rpc, owner) {
  const [tokenAccounts, token2022Accounts] = await Promise.all([
    rpc.getTokenAccountsByOwner(owner, { programId: import_token9.TOKEN_PROGRAM_ADDRESS }).send(),
    rpc.getTokenAccountsByOwner(owner, { programId: import_token_20224.TOKEN_2022_PROGRAM_ADDRESS }).send()
  ]);
  const encoder = (0, import_web35.getBase58Encoder)();
  const decoder = (0, import_token9.getTokenDecoder)();
  const potentialTokens = [...tokenAccounts.value, ...token2022Accounts.value].map((x) => ({
    ...decoder.decode(encoder.encode(x.account.data)),
    owner: x.account.owner
  })).filter((x) => x.amount === 1n);
  const positionAddresses = await Promise.all(
    potentialTokens.map((x) => (0, import_whirlpools_client7.getPositionAddress)(x.mint).then((x2) => x2[0]))
  );
  const positionBundleAddresses = await Promise.all(
    potentialTokens.map(
      (x) => (0, import_whirlpools_client7.getPositionBundleAddress)(x.mint).then((x2) => x2[0])
    )
  );
  const [positions, positionBundles] = await Promise.all([
    (0, import_whirlpools_client7.fetchAllMaybePosition)(rpc, positionAddresses),
    (0, import_whirlpools_client7.fetchAllMaybePositionBundle)(rpc, positionBundleAddresses)
  ]);
  const bundledPositionAddresses = await Promise.all(
    positionBundles.filter((x) => x.exists).flatMap((x) => getPositionInBundleAddresses(x.data))
  );
  const bundledPositions = await (0, import_whirlpools_client7.fetchAllPosition)(
    rpc,
    bundledPositionAddresses
  );
  const bundledPositionMap = bundledPositions.reduce((acc, x) => {
    const current = acc.get(x.data.positionMint) ?? [];
    return acc.set(x.data.positionMint, [...current, x]);
  }, /* @__PURE__ */ new Map());
  const positionsOrBundles = [];
  for (let i = 0; i < potentialTokens.length; i++) {
    const position = positions[i];
    const positionBundle = positionBundles[i];
    const token = potentialTokens[i];
    if (position.exists) {
      positionsOrBundles.push({
        ...position,
        tokenProgram: token.owner,
        isPositionBundle: false
      });
    }
    if (positionBundle.exists) {
      const positions2 = bundledPositionMap.get(positionBundle.data.positionBundleMint) ?? [];
      positionsOrBundles.push({
        ...positionBundle,
        positions: positions2,
        tokenProgram: token.owner,
        isPositionBundle: true
      });
    }
  }
  return positionsOrBundles;
}

// src/swap.ts
var import_web36 = require("@solana/web3.js");
var import_whirlpools_core6 = require("@orca-so/whirlpools-core");
var import_whirlpools_client8 = require("@orca-so/whirlpools-client");
var import_memo4 = require("@solana-program/memo");
var import_token_20225 = require("@solana-program/token-2022");
function createUninitializedTickArray(address4, startTickIndex, programAddress) {
  return {
    address: address4,
    data: {
      startTickIndex,
      ticks: Array((0, import_whirlpools_core6._TICK_ARRAY_SIZE)()).fill({
        initialized: false,
        liquidityNet: 0n,
        feeGrowthOutsideA: 0n,
        feeGrowthOutsideB: 0n,
        rewardGrowthsOutside: [0n, 0n, 0n]
      })
    },
    executable: false,
    lamports: (0, import_web36.lamports)(0n),
    programAddress
  };
}
async function fetchTickArrayOrDefault(rpc, whirlpool) {
  const tickArrayStartIndex = (0, import_whirlpools_core6.getTickArrayStartTickIndex)(
    whirlpool.data.tickCurrentIndex,
    whirlpool.data.tickSpacing
  );
  const offset = whirlpool.data.tickSpacing * (0, import_whirlpools_core6._TICK_ARRAY_SIZE)();
  const tickArrayIndexes = [
    tickArrayStartIndex,
    tickArrayStartIndex + offset,
    tickArrayStartIndex + offset * 2,
    tickArrayStartIndex - offset,
    tickArrayStartIndex - offset * 2
  ];
  const tickArrayAddresses = await Promise.all(
    tickArrayIndexes.map(
      (startIndex) => (0, import_whirlpools_client8.getTickArrayAddress)(whirlpool.address, startIndex).then((x) => x[0])
    )
  );
  const maybeTickArrays = await (0, import_whirlpools_client8.fetchAllMaybeTickArray)(rpc, tickArrayAddresses);
  const tickArrays = [];
  for (let i = 0; i < maybeTickArrays.length; i++) {
    const maybeTickArray = maybeTickArrays[i];
    if (maybeTickArray.exists) {
      tickArrays.push(maybeTickArray);
    } else {
      tickArrays.push(
        createUninitializedTickArray(
          tickArrayAddresses[i],
          tickArrayIndexes[i],
          whirlpool.programAddress
        )
      );
    }
  }
  return tickArrays;
}
function getSwapQuote(params, whirlpool, transferFeeA, transferFeeB, tickArrays, specifiedTokenA, slippageToleranceBps) {
  if ("inputAmount" in params) {
    return (0, import_whirlpools_core6.swapQuoteByInputToken)(
      params.inputAmount,
      specifiedTokenA,
      slippageToleranceBps,
      whirlpool,
      tickArrays,
      transferFeeA,
      transferFeeB
    );
  }
  return (0, import_whirlpools_core6.swapQuoteByOutputToken)(
    params.outputAmount,
    specifiedTokenA,
    slippageToleranceBps,
    whirlpool,
    tickArrays,
    transferFeeA,
    transferFeeB
  );
}
async function swapInstructions(rpc, params, poolAddress, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, signer = FUNDER) {
  const whirlpool = await (0, import_whirlpools_client8.fetchWhirlpool)(rpc, poolAddress);
  const [tokenA, tokenB] = await (0, import_token_20225.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  const specifiedTokenA = params.mint === whirlpool.data.tokenMintA;
  const specifiedInput = "inputAmount" in params;
  const tickArrays = await fetchTickArrayOrDefault(rpc, whirlpool);
  const oracleAddress = await (0, import_whirlpools_client8.getOracleAddress)(whirlpool.address).then(
    (x) => x[0]
  );
  const currentEpoch = await rpc.getEpochInfo().send();
  const transferFeeA = getCurrentTransferFee(tokenA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(tokenB, currentEpoch.epoch);
  const quote = getSwapQuote(
    params,
    whirlpool.data,
    transferFeeA,
    transferFeeB,
    tickArrays.map((x) => x.data),
    specifiedTokenA,
    slippageToleranceBps
  );
  const maxInAmount = "tokenIn" in quote ? quote.tokenIn : quote.tokenMaxIn;
  const aToB = specifiedTokenA === specifiedInput;
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, signer, {
    [whirlpool.data.tokenMintA]: aToB ? maxInAmount : 0n,
    [whirlpool.data.tokenMintB]: aToB ? 0n : maxInAmount
  });
  const instructions = [];
  instructions.push(...createInstructions);
  const specifiedAmount = "inputAmount" in params ? params.inputAmount : params.outputAmount;
  const otherAmountThreshold = "tokenMaxIn" in quote ? quote.tokenMaxIn : quote.tokenMinOut;
  const swapInstruction = (0, import_whirlpools_client8.getSwapV2Instruction)({
    tokenProgramA: tokenA.programAddress,
    tokenProgramB: tokenB.programAddress,
    memoProgram: import_memo4.MEMO_PROGRAM_ADDRESS,
    tokenAuthority: signer,
    whirlpool: whirlpool.address,
    tokenMintA: whirlpool.data.tokenMintA,
    tokenMintB: whirlpool.data.tokenMintB,
    tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
    tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
    tokenVaultA: whirlpool.data.tokenVaultA,
    tokenVaultB: whirlpool.data.tokenVaultB,
    tickArray0: tickArrays[0].address,
    tickArray1: tickArrays[1].address,
    tickArray2: tickArrays[2].address,
    amount: specifiedAmount,
    otherAmountThreshold,
    sqrtPriceLimit: 0,
    amountSpecifiedIsInput: specifiedInput,
    aToB,
    oracle: oracleAddress,
    remainingAccountsInfo: {
      slices: [
        { accountsType: import_whirlpools_client8.AccountsType.SupplementalTickArrays, length: 2 }
      ]
    }
  });
  swapInstruction.accounts.push(
    { address: tickArrays[3].address, role: import_web36.AccountRole.WRITABLE },
    { address: tickArrays[4].address, role: import_web36.AccountRole.WRITABLE }
  );
  instructions.push(swapInstruction);
  instructions.push(...cleanupInstructions);
  return {
    quote,
    instructions
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_ADDRESS,
  DEFAULT_FUNDER,
  DEFAULT_SLIPPAGE_TOLERANCE_BPS,
  DEFAULT_SOL_WRAPPING_STRATEGY,
  DEFAULT_WHIRLPOOLS_CONFIG_ADDRESS,
  DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  FUNDER,
  SLIPPAGE_TOLERANCE_BPS,
  SOL_WRAPPING_STRATEGY,
  SPLASH_POOL_TICK_SPACING,
  WHIRLPOOLS_CONFIG_ADDRESS,
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  closePositionInstructions,
  createConcentratedLiquidityPoolInstructions,
  createSplashPoolInstructions,
  decreaseLiquidityInstructions,
  fetchConcentratedLiquidityPool,
  fetchPositionsForOwner,
  fetchSplashPool,
  fetchWhirlpools,
  harvestPositionInstructions,
  increaseLiquidityInstructions,
  openFullRangePositionInstructions,
  openPositionInstructions,
  resetConfiguration,
  setDefaultFunder,
  setDefaultSlippageToleranceBps,
  setSolWrappingStrategy,
  setWhirlpoolsConfig,
  swapInstructions
});
//# sourceMappingURL=index.cjs.map
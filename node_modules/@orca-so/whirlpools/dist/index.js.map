{"version":3,"sources":["../src/config.ts","../src/createPool.ts","../src/decreaseLiquidity.ts","../src/token.ts","../src/harvest.ts","../src/increaseLiquidity.ts","../src/pool.ts","../src/position.ts","../src/swap.ts"],"sourcesContent":["import { getWhirlpoolsConfigExtensionAddress } from \"@orca-so/whirlpools-client\";\nimport type { Address, TransactionSigner } from \"@solana/web3.js\";\nimport { address, createNoopSigner } from \"@solana/web3.js\";\n\n/**\n * The default (null) address.\n */\nexport const DEFAULT_ADDRESS = address(\"11111111111111111111111111111111\");\n\n/**\n * The default WhirlpoolsConfig address.\n */\nexport const DEFAULT_WHIRLPOOLS_CONFIG_ADDRESS = address(\n  \"2LecshUwdy9xi7meFgHtFJQNSKk4KdTrcpvaB56dP2NQ\",\n);\n\n/**\n * The default WhirlpoolsConfigExtension address.\n */\nexport const DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = address(\n  \"777H5H3Tp9U11uRVRzFwM8BinfiakbaLT8vQpeuhvEiH\",\n);\n\n/**\n * The WhirlpoolsConfig address.\n */\nexport let WHIRLPOOLS_CONFIG_ADDRESS: Address =\n  DEFAULT_WHIRLPOOLS_CONFIG_ADDRESS;\n\n/**\n * The WhirlpoolsConfigExtension address.\n */\nexport let WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS: Address =\n  DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;\n\n/**\n * Updates the WhirlpoolsConfig and WhirlpoolsConfigExtension addresses.\n *\n * @param {Address} whirlpoolsConfigAddress - A WhirlpoolsConfig address.\n * @returns {Promise<void>} - Resolves when the addresses have been updated.\n */\nexport async function setWhirlpoolsConfig(\n  whirlpoolsConfigAddress: Address,\n): Promise<void> {\n  WHIRLPOOLS_CONFIG_ADDRESS = whirlpoolsConfigAddress;\n  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS =\n    await getWhirlpoolsConfigExtensionAddress(whirlpoolsConfigAddress).then(\n      (x) => x[0],\n    );\n}\n\n/**\n * The tick spacing for the Splash pools.\n */\nexport const SPLASH_POOL_TICK_SPACING = 32896;\n\n/**\n * The default funder for transactions. No explicit funder specified.\n */\nexport const DEFAULT_FUNDER: TransactionSigner =\n  createNoopSigner(DEFAULT_ADDRESS);\n\n/**\n * The currently selected funder for transactions.\n */\nexport let FUNDER: TransactionSigner = DEFAULT_FUNDER;\n\n/**\n * Sets the default funder for transactions.\n *\n * @param {TransactionSigner | Address | null} funder - The funder to be set as default, either as an address or a transaction signer.\n */\nexport function setDefaultFunder(\n  funder: TransactionSigner | Address | null,\n): void {\n  if (typeof funder === \"string\") {\n    FUNDER = createNoopSigner(funder);\n  } else {\n    FUNDER = funder ?? createNoopSigner(DEFAULT_ADDRESS);\n  }\n}\n\n/**\n * The default slippage tolerance, expressed in basis points. Value of 100 is equivalent to 1%.\n */\nexport const DEFAULT_SLIPPAGE_TOLERANCE_BPS = 100;\n\n/**\n * The currently selected slippage tolerance, expressed in basis points. Value of 100 is equivalent to 1%.\n */\nexport let SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;\n\n/**\n * Sets the default slippage tolerance for transactions.\n *\n * @param {number} slippageToleranceBps - The slippage tolerance, expressed basis points. Value of 100 is equivalent to 1%.\n */\nexport function setDefaultSlippageToleranceBps(\n  slippageToleranceBps: number,\n): void {\n  SLIPPAGE_TOLERANCE_BPS = Math.floor(slippageToleranceBps);\n}\n\n/**\n * Defines the strategy for handling SOL wrapping in a transaction.\n *\n * - **Keypair**:\n *   Creates an auxiliary token account using a keypair. Optionally adds funds to the account. Closes it at the end of the transaction.\n *\n * - **Seed**:\n *   Functions similarly to Keypair, but uses a seed account instead.\n *\n * - **ATA**:\n *   Creates an associated token account (ATA) for `NATIVE_MINT` if necessary. Optionally adds funds to the ATA. Closes it at the end of the transaction if it was newly created.\n *\n * - **None**:\n *   Uses or creates the ATA without performing any SOL wrapping or unwrapping.\n */\nexport type SolWrappingStrategy = \"keypair\" | \"seed\" | \"ata\" | \"none\";\n\n/**\n * The default sol wrapping strategy.\n */\nexport const DEFAULT_SOL_WRAPPING_STRATEGY: SolWrappingStrategy = \"keypair\";\n\n/**\n * The currently selected sol wrapping strategy.\n */\nexport let SOL_WRAPPING_STRATEGY: SolWrappingStrategy =\n  DEFAULT_SOL_WRAPPING_STRATEGY;\n\n/**\n * Sets the sol wrapping strategy.\n *\n * @param {SolWrappingStrategy} strategy - The sol wrapping strategy.\n */\nexport function setSolWrappingStrategy(strategy: SolWrappingStrategy): void {\n  SOL_WRAPPING_STRATEGY = strategy;\n}\n\n/**\n * Resets the configuration to its default state.\n *\n * @returns {Promise<void>} - Resolves when the configuration has been reset.\n */\nexport function resetConfiguration() {\n  WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESS;\n  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS =\n    DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;\n  FUNDER = DEFAULT_FUNDER;\n  SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;\n  SOL_WRAPPING_STRATEGY = DEFAULT_SOL_WRAPPING_STRATEGY;\n}\n","import {\n  getFeeTierAddress,\n  getInitializePoolV2Instruction,\n  getInitializeTickArrayInstruction,\n  getTickArrayAddress,\n  getTickArraySize,\n  getTokenBadgeAddress,\n  getWhirlpoolAddress,\n  getWhirlpoolSize,\n} from \"@orca-so/whirlpools-client\";\nimport type {\n  Address,\n  GetMinimumBalanceForRentExemptionApi,\n  GetMultipleAccountsApi,\n  IInstruction,\n  LamportsUnsafeBeyond2Pow53Minus1,\n  Rpc,\n  TransactionSigner,\n} from \"@solana/web3.js\";\nimport { generateKeyPairSigner } from \"@solana/web3.js\";\nimport {\n  DEFAULT_ADDRESS,\n  FUNDER,\n  SPLASH_POOL_TICK_SPACING,\n  WHIRLPOOLS_CONFIG_ADDRESS,\n} from \"./config\";\nimport {\n  getFullRangeTickIndexes,\n  getTickArrayStartTickIndex,\n  priceToSqrtPrice,\n  sqrtPriceToTickIndex,\n} from \"@orca-so/whirlpools-core\";\nimport { fetchAllMint, getTokenSize } from \"@solana-program/token\";\nimport assert from \"assert\";\n\n/**\n * Represents the instructions and metadata for creating a pool.\n */\nexport type CreatePoolInstructions = {\n  /** The list of instructions needed to create the pool. */\n  instructions: IInstruction[];\n\n  /** The estimated rent exemption cost for initializing the pool, in lamports. */\n  estInitializationCost: LamportsUnsafeBeyond2Pow53Minus1;\n\n  /** The address of the newly created pool. */\n  poolAddress: Address;\n};\n\n/**\n * Creates the necessary instructions to initialize a Splash Pool on Orca Whirlpools.\n *\n * @param {SolanaRpc} rpc - A Solana RPC client for communicating with the blockchain.\n * @param {Address} tokenMintA - The first token mint address to include in the pool.\n * @param {Address} tokenMintB - The second token mint address to include in the pool.\n * @param {number} [initialPrice=1] - The initial price of token 1 in terms of token 2.\n * @param {TransactionSigner} [funder=FUNDER] - The account that will fund the initialization process.\n *\n * @returns {Promise<CreatePoolInstructions>} A promise that resolves to an object containing the pool creation instructions, the estimated initialization cost, and the pool address.\n *\n * @example\n * import { createSplashPoolInstructions } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner();\n * await devnetRpc.requestAirdrop(wallet.address, lamports(1000000000n)).send();\n *\n * const tokenMintOne = \"TOKEN_MINT_ADDRESS_1\";\n * const tokenMintTwo = \"TOKEN_MINT_ADDRESS_2\";\n * const initialPrice = 0.01;\n *\n * const { poolAddress, instructions, initializationCost } = await createSplashPoolInstructions(\n *   devnetRpc,\n *   tokenMintOne,\n *   tokenMintTwo,\n *   initialPrice,\n *   wallet\n * );\n */\nexport function createSplashPoolInstructions(\n  rpc: Rpc<GetMultipleAccountsApi & GetMinimumBalanceForRentExemptionApi>,\n  tokenMintA: Address,\n  tokenMintB: Address,\n  initialPrice: number = 1,\n  funder: TransactionSigner = FUNDER,\n): Promise<CreatePoolInstructions> {\n  return createConcentratedLiquidityPoolInstructions(\n    rpc,\n    tokenMintA,\n    tokenMintB,\n    SPLASH_POOL_TICK_SPACING,\n    initialPrice,\n    funder,\n  );\n}\n\n/**\n * Creates the necessary instructions to initialize a Concentrated Liquidity Pool (CLMM) on Orca Whirlpools.\n *\n * @param {SolanaRpc} rpc - A Solana RPC client for communicating with the blockchain.\n * @param {Address} tokenMintA - The first token mint address to include in the pool.\n * @param {Address} tokenMintB - The second token mint address to include in the pool.\n * @param {number} tickSpacing - The spacing between price ticks for the pool.\n * @param {number} [initialPrice=1] - The initial price of token 1 in terms of token 2.\n * @param {TransactionSigner} [funder=FUNDER] - The account that will fund the initialization process.\n *\n * @returns {Promise<CreatePoolInstructions>} A promise that resolves to an object containing the pool creation instructions, the estimated initialization cost, and the pool address.\n *\n * @example\n * import { createConcentratedLiquidityPool } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner();\n * await devnetRpc.requestAirdrop(wallet.address, lamports(1000000000n)).send();\n *\n * const tokenMintOne = \"TOKEN_MINT_ADDRESS_1\";\n * const tokenMintTwo = \"TOKEN_MINT_ADDRESS_2\";\n * const tickSpacing = 64;\n * const initialPrice = 0.01;\n *\n * const { poolAddress, instructions, initializationCost } = await createConcentratedLiquidityPool(\n *   devnetRpc,\n *   tokenMintOne,\n *   tokenMintTwo,\n *   tickSpacing,\n *   initialPrice,\n *   wallet\n * );\n */\nexport async function createConcentratedLiquidityPoolInstructions(\n  rpc: Rpc<GetMultipleAccountsApi & GetMinimumBalanceForRentExemptionApi>,\n  tokenMintA: Address,\n  tokenMintB: Address,\n  tickSpacing: number,\n  initialPrice: number = 1,\n  funder: TransactionSigner = FUNDER,\n): Promise<CreatePoolInstructions> {\n  assert(\n    funder.address !== DEFAULT_ADDRESS,\n    \"Either supply a funder or set the default funder\",\n  );\n  assert(\n    Buffer.from(tokenMintA) < Buffer.from(tokenMintB),\n    \"Token order needs to be flipped to match the canonical ordering (i.e. sorted on the byte repr. of the mint pubkeys)\",\n  );\n  const instructions: IInstruction[] = [];\n  let stateSpace = 0;\n\n  // Since TE mint data is an extension of T mint data, we can use the same fetch function\n  const [mintA, mintB] = await fetchAllMint(rpc, [tokenMintA, tokenMintB]);\n  const decimalsA = mintA.data.decimals;\n  const decimalsB = mintB.data.decimals;\n  const tokenProgramA = mintA.programAddress;\n  const tokenProgramB = mintB.programAddress;\n\n  const initialSqrtPrice = priceToSqrtPrice(initialPrice, decimalsA, decimalsB);\n\n  const [\n    poolAddress,\n    feeTier,\n    tokenBadgeA,\n    tokenBadgeB,\n    tokenVaultA,\n    tokenVaultB,\n  ] = await Promise.all([\n    getWhirlpoolAddress(\n      WHIRLPOOLS_CONFIG_ADDRESS,\n      tokenMintA,\n      tokenMintB,\n      tickSpacing,\n    ).then((x) => x[0]),\n    getFeeTierAddress(WHIRLPOOLS_CONFIG_ADDRESS, tickSpacing).then((x) => x[0]),\n    getTokenBadgeAddress(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintA).then(\n      (x) => x[0],\n    ),\n    getTokenBadgeAddress(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintB).then(\n      (x) => x[0],\n    ),\n    generateKeyPairSigner(),\n    generateKeyPairSigner(),\n  ]);\n\n  instructions.push(\n    getInitializePoolV2Instruction({\n      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,\n      tokenMintA,\n      tokenMintB,\n      tokenBadgeA,\n      tokenBadgeB,\n      funder,\n      whirlpool: poolAddress,\n      tokenVaultA,\n      tokenVaultB,\n      tokenProgramA,\n      tokenProgramB,\n      feeTier,\n      tickSpacing,\n      initialSqrtPrice,\n    }),\n  );\n\n  stateSpace += getTokenSize() * 2;\n  stateSpace += getWhirlpoolSize();\n\n  const fullRange = getFullRangeTickIndexes(tickSpacing);\n  const lowerTickIndex = getTickArrayStartTickIndex(\n    fullRange.tickLowerIndex,\n    tickSpacing,\n  );\n  const upperTickIndex = getTickArrayStartTickIndex(\n    fullRange.tickUpperIndex,\n    tickSpacing,\n  );\n  const initialTickIndex = sqrtPriceToTickIndex(initialSqrtPrice);\n  const currentTickIndex = getTickArrayStartTickIndex(\n    initialTickIndex,\n    tickSpacing,\n  );\n\n  const tickArrayIndexes = Array.from(\n    new Set([lowerTickIndex, upperTickIndex, currentTickIndex]),\n  );\n\n  const tickArrayAddresses = await Promise.all(\n    tickArrayIndexes.map((x) =>\n      getTickArrayAddress(poolAddress, x).then((x) => x[0]),\n    ),\n  );\n\n  for (let i = 0; i < tickArrayIndexes.length; i++) {\n    instructions.push(\n      getInitializeTickArrayInstruction({\n        whirlpool: poolAddress,\n        funder,\n        tickArray: tickArrayAddresses[i],\n        startTickIndex: tickArrayIndexes[i],\n      }),\n    );\n    stateSpace += getTickArraySize();\n  }\n\n  const nonRefundableRent = await rpc\n    .getMinimumBalanceForRentExemption(BigInt(stateSpace))\n    .send();\n\n  return {\n    instructions,\n    poolAddress,\n    estInitializationCost: nonRefundableRent,\n  };\n}\n","import type { Whirlpool } from \"@orca-so/whirlpools-client\";\nimport {\n  fetchAllTickArray,\n  fetchPosition,\n  fetchWhirlpool,\n  getClosePositionInstruction,\n  getClosePositionWithTokenExtensionsInstruction,\n  getCollectFeesV2Instruction,\n  getCollectRewardV2Instruction,\n  getDecreaseLiquidityV2Instruction,\n  getPositionAddress,\n  getTickArrayAddress,\n  getUpdateFeesAndRewardsInstruction,\n} from \"@orca-so/whirlpools-client\";\nimport type {\n  CollectFeesQuote,\n  CollectRewardsQuote,\n  DecreaseLiquidityQuote,\n  TickRange,\n  TransferFee,\n} from \"@orca-so/whirlpools-core\";\nimport {\n  _MAX_TICK_INDEX,\n  _MIN_TICK_INDEX,\n  getTickArrayStartTickIndex,\n  decreaseLiquidityQuote,\n  decreaseLiquidityQuoteA,\n  decreaseLiquidityQuoteB,\n  collectFeesQuote,\n  collectRewardsQuote,\n  getTickIndexInArray,\n} from \"@orca-so/whirlpools-core\";\nimport type {\n  Address,\n  GetAccountInfoApi,\n  GetMinimumBalanceForRentExemptionApi,\n  GetMultipleAccountsApi,\n  IInstruction,\n  Rpc,\n  TransactionSigner,\n} from \"@solana/web3.js\";\nimport { DEFAULT_ADDRESS, FUNDER, SLIPPAGE_TOLERANCE_BPS } from \"./config\";\nimport {\n  findAssociatedTokenPda,\n  TOKEN_PROGRAM_ADDRESS,\n} from \"@solana-program/token\";\nimport {\n  getCurrentTransferFee,\n  prepareTokenAccountsInstructions,\n} from \"./token\";\nimport {\n  fetchAllMint,\n  fetchAllMaybeMint,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport { MEMO_PROGRAM_ADDRESS } from \"@solana-program/memo\";\nimport assert from \"assert\";\n\n// TODO: allow specify number as well as bigint\n// TODO: transfer hook\n\n/**\n * Represents the parameters for decreasing liquidity.\n * You must choose only one of the properties (`liquidity`, `tokenA`, or `tokenB`).\n * The SDK will compute the other two based on the input provided.\n */\nexport type DecreaseLiquidityQuoteParam =\n  | {\n      /** The amount of liquidity to decrease.*/\n      liquidity: bigint;\n    }\n  | {\n      /** The amount of Token A to withdraw.*/\n      tokenA: bigint;\n    }\n  | {\n      /** The amount of Token B to withdraw.*/\n      tokenB: bigint;\n    };\n\n/**\n * Represents the instructions and quote for decreasing liquidity in a position.\n */\nexport type DecreaseLiquidityInstructions = {\n  /** The quote details for decreasing liquidity, including the liquidity delta, estimated tokens, and minimum token amounts based on slippage tolerance. */\n  quote: DecreaseLiquidityQuote;\n\n  /** The list of instructions required to decrease liquidity. */\n  instructions: IInstruction[];\n};\n\nfunction getDecreaseLiquidityQuote(\n  param: DecreaseLiquidityQuoteParam,\n  pool: Whirlpool,\n  tickRange: TickRange,\n  slippageToleranceBps: number,\n  transferFeeA: TransferFee | undefined,\n  transferFeeB: TransferFee | undefined,\n): DecreaseLiquidityQuote {\n  if (\"liquidity\" in param) {\n    return decreaseLiquidityQuote(\n      param.liquidity,\n      slippageToleranceBps,\n      pool.sqrtPrice,\n      tickRange.tickLowerIndex,\n      tickRange.tickUpperIndex,\n      transferFeeA,\n      transferFeeB,\n    );\n  } else if (\"tokenA\" in param) {\n    return decreaseLiquidityQuoteA(\n      param.tokenA,\n      slippageToleranceBps,\n      pool.sqrtPrice,\n      tickRange.tickLowerIndex,\n      tickRange.tickUpperIndex,\n      transferFeeA,\n      transferFeeB,\n    );\n  } else {\n    return decreaseLiquidityQuoteB(\n      param.tokenB,\n      slippageToleranceBps,\n      pool.sqrtPrice,\n      tickRange.tickLowerIndex,\n      tickRange.tickUpperIndex,\n      transferFeeA,\n      transferFeeB,\n    );\n  }\n}\n\n/**\n * Generates instructions to decrease liquidity from an existing position in an Orca Whirlpool.\n *\n * @param {SolanaRpc} rpc - A Solana RPC client for fetching necessary accounts and pool data.\n * @param {Address} positionMintAddress - The mint address of the NFT that represents ownership of the position from which liquidity will be removed.\n * @param {DecreaseLiquidityQuoteParam} param - Defines the liquidity removal method (liquidity, tokenA, or tokenB).\n * @param {number} [slippageToleranceBps=SLIPPAGE_TOLERANCE_BPS] - The acceptable slippage tolerance in basis points.\n * @param {TransactionSigner} [authority=FUNDER] - The account authorizing the liquidity removal.\n *\n * @returns {Promise<DecreaseLiquidityInstructions>} A promise resolving to an object containing the decrease liquidity quote and instructions.\n *\n * @example\n * import { decreaseLiquidityInstructions } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner();\n * await devnetRpc.requestAirdrop(wallet.address, lamports(1000000000n)).send();\n *\n * const positionMint = \"POSITION_MINT\";\n *\n * const param = { liquidity: 500_000n };\n *\n * const { quote, instructions } = await decreaseLiquidityInstructions(\n *   devnetRpc,\n *   positionMint,\n *   param,\n *   100,\n *   wallet\n * );\n */\nexport async function decreaseLiquidityInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi\n  >,\n  positionMintAddress: Address,\n  param: DecreaseLiquidityQuoteParam,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  authority: TransactionSigner = FUNDER,\n): Promise<DecreaseLiquidityInstructions> {\n  assert(\n    authority.address !== DEFAULT_ADDRESS,\n    \"Either supply the authority or set the default funder\",\n  );\n\n  const positionAddress = await getPositionAddress(positionMintAddress);\n  const position = await fetchPosition(rpc, positionAddress[0]);\n  const whirlpool = await fetchWhirlpool(rpc, position.data.whirlpool);\n\n  const currentEpoch = await rpc.getEpochInfo().send();\n  const [mintA, mintB, positionMint] = await fetchAllMint(rpc, [\n    whirlpool.data.tokenMintA,\n    whirlpool.data.tokenMintB,\n    positionMintAddress,\n  ]);\n  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);\n  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);\n\n  const quote = getDecreaseLiquidityQuote(\n    param,\n    whirlpool.data,\n    position.data,\n    slippageToleranceBps,\n    transferFeeA,\n    transferFeeB,\n  );\n  const instructions: IInstruction[] = [];\n\n  const lowerTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickLowerIndex,\n    whirlpool.data.tickSpacing,\n  );\n  const upperTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickUpperIndex,\n    whirlpool.data.tickSpacing,\n  );\n\n  const [positionTokenAccount, tickArrayLower, tickArrayUpper] =\n    await Promise.all([\n      findAssociatedTokenPda({\n        owner: authority.address,\n        mint: positionMintAddress,\n        tokenProgram: positionMint.programAddress,\n      }).then((x) => x[0]),\n      getTickArrayAddress(whirlpool.address, lowerTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n      getTickArrayAddress(whirlpool.address, upperTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n    ]);\n\n  const { createInstructions, cleanupInstructions, tokenAccountAddresses } =\n    await prepareTokenAccountsInstructions(rpc, authority, [\n      whirlpool.data.tokenMintA,\n      whirlpool.data.tokenMintB,\n    ]);\n\n  instructions.push(...createInstructions);\n\n  instructions.push(\n    getDecreaseLiquidityV2Instruction({\n      whirlpool: whirlpool.address,\n      positionAuthority: authority,\n      position: position.address,\n      positionTokenAccount,\n      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n      tokenVaultA: whirlpool.data.tokenVaultA,\n      tokenVaultB: whirlpool.data.tokenVaultB,\n      tokenMintA: whirlpool.data.tokenMintA,\n      tokenMintB: whirlpool.data.tokenMintB,\n      tokenProgramA: mintA.programAddress,\n      tokenProgramB: mintB.programAddress,\n      memoProgram: MEMO_PROGRAM_ADDRESS,\n      tickArrayLower,\n      tickArrayUpper,\n      liquidityAmount: quote.liquidityDelta,\n      tokenMinA: quote.tokenMinA,\n      tokenMinB: quote.tokenMinB,\n      remainingAccountsInfo: null,\n    }),\n  );\n\n  instructions.push(...cleanupInstructions);\n\n  return { quote, instructions };\n}\n\n/**\n * Represents the instructions and quotes for closing a liquidity position in an Orca Whirlpool.\n * Extends `DecreaseLiquidityInstructions` and adds additional fee and reward details.\n */\nexport type ClosePositionInstructions = DecreaseLiquidityInstructions & {\n  /** The fees collected from the position, including the amounts for token A (`fee_owed_a`) and token B (`fee_owed_b`). */\n  feesQuote: CollectFeesQuote;\n\n  /** The rewards collected from the position, including up to three reward tokens (`reward_owed_1`, `reward_owed_2`, and `reward_owed_3`). */\n  rewardsQuote: CollectRewardsQuote;\n};\n\n/**\n * Generates instructions to close a liquidity position in an Orca Whirlpool. This includes collecting all fees,\n * rewards, removing any remaining liquidity, and closing the position.\n *\n * @param {SolanaRpc} rpc - A Solana RPC client for fetching accounts and pool data.\n * @param {Address} positionMintAddress - The mint address of the NFT that represents ownership of the position to be closed.\n * @param {DecreaseLiquidityQuoteParam} param - The parameters for removing liquidity (liquidity, tokenA, or tokenB).\n * @param {number} [slippageToleranceBps=SLIPPAGE_TOLERANCE_BPS] - The acceptable slippage tolerance in basis points.\n * @param {TransactionSigner} [authority=FUNDER] - The account authorizing the transaction.\n *\n * @returns {Promise<ClosePositionInstructions>} A promise resolving to an object containing instructions, fees quote, rewards quote, and the liquidity quote for the closed position.\n *\n * @example\n * import { closePositionInstructions } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner();\n * await devnetRpc.requestAirdrop(wallet.address, lamports(1000000000n)).send();\n *\n * const positionMint = \"POSITION_MINT\";\n *\n * const param = { liquidity: 500_000n };\n *\n * const { instructions, quote, feesQuote, rewardsQuote } = await closePositionInstructions(\n *   devnetRpc,\n *   positionMint,\n *   param,\n *   100,\n *   wallet\n * );\n */\nexport async function closePositionInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi\n  >,\n  positionMintAddress: Address,\n  param: DecreaseLiquidityQuoteParam,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  authority: TransactionSigner = FUNDER,\n): Promise<ClosePositionInstructions> {\n  assert(\n    authority.address !== DEFAULT_ADDRESS,\n    \"Either supply an authority or set the default funder\",\n  );\n\n  const positionAddress = await getPositionAddress(positionMintAddress);\n  const position = await fetchPosition(rpc, positionAddress[0]);\n  const whirlpool = await fetchWhirlpool(rpc, position.data.whirlpool);\n\n  const currentEpoch = await rpc.getEpochInfo().send();\n  const [mintA, mintB, positionMint, ...rewardMints] = await fetchAllMaybeMint(\n    rpc,\n    [\n      whirlpool.data.tokenMintA,\n      whirlpool.data.tokenMintB,\n      positionMintAddress,\n      ...whirlpool.data.rewardInfos\n        .map((x) => x.mint)\n        .filter((x) => x !== DEFAULT_ADDRESS),\n    ],\n  );\n\n  assert(mintA.exists, \"Token A not found\");\n  assert(mintB.exists, \"Token B not found\");\n  assert(positionMint.exists, \"Position mint not found\");\n\n  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);\n  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);\n\n  const quote = getDecreaseLiquidityQuote(\n    param,\n    whirlpool.data,\n    position.data,\n    slippageToleranceBps,\n    transferFeeA,\n    transferFeeB,\n  );\n\n  const lowerTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickLowerIndex,\n    whirlpool.data.tickSpacing,\n  );\n  const upperTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickUpperIndex,\n    whirlpool.data.tickSpacing,\n  );\n\n  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] =\n    await Promise.all([\n      findAssociatedTokenPda({\n        owner: authority.address,\n        mint: positionMintAddress,\n        tokenProgram: positionMint.programAddress,\n      }).then((x) => x[0]),\n      getTickArrayAddress(whirlpool.address, lowerTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n      getTickArrayAddress(whirlpool.address, upperTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n    ]);\n\n  const [lowerTickArray, upperTickArray] = await fetchAllTickArray(rpc, [\n    lowerTickArrayAddress,\n    upperTickArrayAddress,\n  ]);\n\n  const lowerTick =\n    lowerTickArray.data.ticks[\n      getTickIndexInArray(\n        position.data.tickLowerIndex,\n        lowerTickArrayStartIndex,\n        whirlpool.data.tickSpacing,\n      )\n    ];\n  const upperTick =\n    upperTickArray.data.ticks[\n      getTickIndexInArray(\n        position.data.tickUpperIndex,\n        upperTickArrayStartIndex,\n        whirlpool.data.tickSpacing,\n      )\n    ];\n\n  const feesQuote = collectFeesQuote(\n    whirlpool.data,\n    position.data,\n    lowerTick,\n    upperTick,\n    transferFeeA,\n    transferFeeB,\n  );\n  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1000));\n  const rewardsQuote = collectRewardsQuote(\n    whirlpool.data,\n    position.data,\n    lowerTick,\n    upperTick,\n    currentUnixTimestamp,\n    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),\n    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),\n    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch),\n  );\n\n  const requiredMints: Address[] = [];\n  if (\n    quote.liquidityDelta > 0n ||\n    feesQuote.feeOwedA > 0n ||\n    feesQuote.feeOwedB > 0n\n  ) {\n    requiredMints.push(whirlpool.data.tokenMintA);\n    requiredMints.push(whirlpool.data.tokenMintB);\n  }\n  if (rewardsQuote.rewards[0].rewardsOwed > 0n) {\n    requiredMints.push(whirlpool.data.rewardInfos[0].mint);\n  }\n  if (rewardsQuote.rewards[1].rewardsOwed > 0n) {\n    requiredMints.push(whirlpool.data.rewardInfos[1].mint);\n  }\n  if (rewardsQuote.rewards[2].rewardsOwed > 0n) {\n    requiredMints.push(whirlpool.data.rewardInfos[2].mint);\n  }\n\n  // FIXME: this creates the accounts even if they are not actually needed\n  // (no rewards, fees, to decrease liquidity, etc.)\n  const { createInstructions, cleanupInstructions, tokenAccountAddresses } =\n    await prepareTokenAccountsInstructions(rpc, authority, requiredMints);\n\n  const instructions: IInstruction[] = [];\n  instructions.push(...createInstructions);\n\n  if (position.data.liquidity > 0n) {\n    instructions.push(\n      getUpdateFeesAndRewardsInstruction({\n        whirlpool: whirlpool.address,\n        position: positionAddress[0],\n        tickArrayLower: lowerTickArrayAddress,\n        tickArrayUpper: upperTickArrayAddress,\n      }),\n    );\n  }\n\n  if (quote.liquidityDelta > 0n) {\n    instructions.push(\n      getDecreaseLiquidityV2Instruction({\n        whirlpool: whirlpool.address,\n        positionAuthority: authority,\n        position: positionAddress[0],\n        positionTokenAccount,\n        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n        tokenVaultA: whirlpool.data.tokenVaultA,\n        tokenVaultB: whirlpool.data.tokenVaultB,\n        tickArrayLower: lowerTickArrayAddress,\n        tickArrayUpper: upperTickArrayAddress,\n        liquidityAmount: quote.liquidityDelta,\n        tokenMinA: quote.tokenMinA,\n        tokenMinB: quote.tokenMinB,\n        tokenMintA: whirlpool.data.tokenMintA,\n        tokenMintB: whirlpool.data.tokenMintB,\n        tokenProgramA: mintA.programAddress,\n        tokenProgramB: mintB.programAddress,\n        memoProgram: MEMO_PROGRAM_ADDRESS,\n        remainingAccountsInfo: null,\n      }),\n    );\n  }\n\n  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {\n    instructions.push(\n      getCollectFeesV2Instruction({\n        whirlpool: whirlpool.address,\n        positionAuthority: authority,\n        position: positionAddress[0],\n        positionTokenAccount,\n        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n        tokenVaultA: whirlpool.data.tokenVaultA,\n        tokenVaultB: whirlpool.data.tokenVaultB,\n        tokenMintA: whirlpool.data.tokenMintA,\n        tokenMintB: whirlpool.data.tokenMintB,\n        tokenProgramA: mintA.programAddress,\n        tokenProgramB: mintB.programAddress,\n        memoProgram: MEMO_PROGRAM_ADDRESS,\n        remainingAccountsInfo: null,\n      }),\n    );\n  }\n\n  for (let i = 0; i < rewardsQuote.rewards.length; i++) {\n    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {\n      continue;\n    }\n    const rewardMint = rewardMints[i];\n    assert(rewardMint.exists, `Reward mint ${i} not found`);\n    instructions.push(\n      getCollectRewardV2Instruction({\n        whirlpool: whirlpool.address,\n        positionAuthority: authority,\n        position: positionAddress[0],\n        positionTokenAccount,\n        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],\n        rewardVault: whirlpool.data.rewardInfos[i].vault,\n        rewardIndex: i,\n        rewardMint: rewardMint.address,\n        rewardTokenProgram: rewardMint.programAddress,\n        memoProgram: MEMO_PROGRAM_ADDRESS,\n        remainingAccountsInfo: null,\n      }),\n    );\n  }\n\n  switch (positionMint.programAddress) {\n    case TOKEN_PROGRAM_ADDRESS:\n      instructions.push(\n        getClosePositionInstruction({\n          positionAuthority: authority,\n          position: positionAddress[0],\n          positionTokenAccount,\n          positionMint: positionMintAddress,\n          receiver: authority.address,\n        }),\n      );\n      break;\n    case TOKEN_2022_PROGRAM_ADDRESS:\n      instructions.push(\n        getClosePositionWithTokenExtensionsInstruction({\n          positionAuthority: authority,\n          position: positionAddress[0],\n          positionTokenAccount,\n          positionMint: positionMintAddress,\n          receiver: authority.address,\n          token2022Program: TOKEN_2022_PROGRAM_ADDRESS,\n        }),\n      );\n      break;\n    default:\n      throw new Error(\"Invalid token program\");\n  }\n\n  instructions.push(...cleanupInstructions);\n\n  return {\n    instructions,\n    quote,\n    feesQuote,\n    rewardsQuote,\n  };\n}\n","import {\n  fetchAllMaybeToken,\n  fetchAllMint,\n  findAssociatedTokenPda,\n  getCloseAccountInstruction,\n  getCreateAssociatedTokenInstruction,\n  getInitializeAccount3Instruction,\n  getSyncNativeInstruction,\n  getTokenSize,\n  TOKEN_PROGRAM_ADDRESS,\n} from \"@solana-program/token\";\nimport type {\n  Account,\n  Address,\n  GetAccountInfoApi,\n  GetMinimumBalanceForRentExemptionApi,\n  GetMultipleAccountsApi,\n  IInstruction,\n  MaybeAccount,\n  Rpc,\n  TransactionSigner,\n} from \"@solana/web3.js\";\nimport {\n  address,\n  generateKeyPairSigner,\n  getAddressDecoder,\n  getAddressEncoder,\n} from \"@solana/web3.js\";\nimport { SOL_WRAPPING_STRATEGY } from \"./config\";\nimport {\n  getCreateAccountInstruction,\n  getCreateAccountWithSeedInstruction,\n  getTransferSolInstruction,\n} from \"@solana-program/system\";\nimport type { Mint } from \"@solana-program/token-2022\";\nimport type { TransferFee } from \"@orca-so/whirlpools-core\";\n\n// This file is not exported through the barrel file\n\n/** The public key for the native mint (SOL) */\nexport const NATIVE_MINT = address(\n  \"So11111111111111111111111111111111111111112\",\n);\n\n/**\n * Represents the instructions and associated addresses for preparing token accounts during a transaction.\n */\ntype TokenAccountInstructions = {\n  /** A list of instructions required to create the necessary token accounts. */\n  createInstructions: IInstruction[];\n\n  /** A list of instructions to clean up (e.g., close) token accounts after the transaction is complete. */\n  cleanupInstructions: IInstruction[];\n\n  /** A mapping of mint addresses to their respective token account addresses. */\n  tokenAccountAddresses: Record<Address, Address>;\n};\n\nfunction mintFilter(x: Address) {\n  if (SOL_WRAPPING_STRATEGY === \"none\" || SOL_WRAPPING_STRATEGY === \"ata\") {\n    return true;\n  }\n  return x != NATIVE_MINT;\n}\n\n/**\n *\n * Prepare token acounts required for a transaction. This will create\n * ATAs for the supplied mints.\n *\n * The NATIVE_MINT is a special case where this function will optionally wrap/unwrap\n * SOL based on the SOL_WRAPPING_STRATEGY.\n *\n * @param rpc\n * @param owner the owner to create token accounts for\n * @param spec the mints (and amounts) required in the token accounts\n * @returns Instructions and addresses for the required token accounts\n */\nexport async function prepareTokenAccountsInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi\n  >,\n  owner: TransactionSigner,\n  spec: Address[] | Record<Address, bigint | number>,\n): Promise<TokenAccountInstructions> {\n  const mintAddresses = Array.isArray(spec)\n    ? spec\n    : (Object.keys(spec) as Address[]);\n  const solMintIndex = mintAddresses.indexOf(NATIVE_MINT);\n  const hasSolMint = solMintIndex !== -1;\n  const mints = await fetchAllMint(rpc, mintAddresses.filter(mintFilter));\n  const tokenAddresses = await Promise.all(\n    mints.map((mint) =>\n      findAssociatedTokenPda({\n        owner: owner.address,\n        mint: mint.address,\n        tokenProgram: mint.programAddress,\n      }).then((x) => x[0]),\n    ),\n  );\n  const tokenAccounts = await fetchAllMaybeToken(rpc, tokenAddresses);\n  const tokenAccountAddresses: Record<Address, Address> = {};\n\n  const createInstructions: IInstruction[] = [];\n  const cleanupInstructions: IInstruction[] = [];\n\n  for (let i = 0; i < mints.length; i++) {\n    const mint = mints[i];\n    const tokenAccount = tokenAccounts[i];\n    tokenAccountAddresses[mint.address] = tokenAccount.address;\n    if (tokenAccount.exists) {\n      continue;\n    }\n    createInstructions.push(\n      getCreateAssociatedTokenInstruction({\n        payer: owner,\n        owner: owner.address,\n        ata: tokenAccount.address,\n        mint: mint.address,\n        tokenProgram: mint.programAddress,\n      }),\n    );\n  }\n\n  if (hasSolMint && SOL_WRAPPING_STRATEGY === \"keypair\") {\n    const keypair = await generateKeyPairSigner();\n    const space = getTokenSize();\n    const lamports = await rpc\n      .getMinimumBalanceForRentExemption(BigInt(space))\n      .send();\n    createInstructions.push(\n      getCreateAccountInstruction({\n        payer: owner,\n        newAccount: keypair,\n        lamports,\n        space,\n        programAddress: TOKEN_PROGRAM_ADDRESS,\n      }),\n      getInitializeAccount3Instruction({\n        account: keypair.address,\n        mint: NATIVE_MINT,\n        owner: owner.address,\n      }),\n    );\n    cleanupInstructions.push(\n      getCloseAccountInstruction({\n        account: keypair.address,\n        owner,\n        destination: owner.address,\n      }),\n    );\n    tokenAccountAddresses[NATIVE_MINT] = keypair.address;\n  }\n\n  if (hasSolMint && SOL_WRAPPING_STRATEGY === \"seed\") {\n    const space = getTokenSize();\n    const amount = await rpc\n      .getMinimumBalanceForRentExemption(BigInt(space))\n      .send();\n\n    // Generating secure seed takes longer and is not really needed here.\n    // With date, it should only create collisions if the same owner\n    // creates multiple accounts at exactly the same time (in ms)\n    const seed = Date.now().toString();\n    const buffer = await crypto.subtle.digest(\n      \"SHA-256\",\n      Buffer.concat([\n        Buffer.from(getAddressEncoder().encode(owner.address)),\n        Buffer.from(seed),\n        Buffer.from(getAddressEncoder().encode(TOKEN_PROGRAM_ADDRESS)),\n      ]),\n    );\n    tokenAccountAddresses[NATIVE_MINT] = getAddressDecoder().decode(\n      new Uint8Array(buffer),\n    );\n\n    createInstructions.push(\n      getCreateAccountWithSeedInstruction({\n        payer: owner,\n        newAccount: tokenAccountAddresses[NATIVE_MINT],\n        base: owner.address,\n        baseAccount: owner,\n        seed: seed,\n        space,\n        amount,\n        programAddress: TOKEN_PROGRAM_ADDRESS,\n      }),\n      getInitializeAccount3Instruction({\n        account: tokenAccountAddresses[NATIVE_MINT],\n        mint: NATIVE_MINT,\n        owner: owner.address,\n      }),\n    );\n\n    cleanupInstructions.push(\n      getCloseAccountInstruction({\n        account: tokenAccountAddresses[NATIVE_MINT],\n        owner,\n        destination: owner.address,\n      }),\n    );\n  }\n\n  if (hasSolMint && SOL_WRAPPING_STRATEGY === \"ata\") {\n    const account = tokenAccounts[solMintIndex];\n    if (!account.exists) {\n      cleanupInstructions.push(\n        getCloseAccountInstruction({\n          account: account.address,\n          owner,\n          destination: owner.address,\n        }),\n      );\n    }\n  }\n\n  if (\n    hasSolMint &&\n    !Array.isArray(spec) &&\n    spec[NATIVE_MINT] > 0 &&\n    SOL_WRAPPING_STRATEGY !== \"none\"\n  ) {\n    createInstructions.push(\n      getTransferSolInstruction({\n        source: owner,\n        destination: tokenAccountAddresses[NATIVE_MINT],\n        amount: spec[NATIVE_MINT],\n      }),\n      getSyncNativeInstruction({\n        account: tokenAccountAddresses[NATIVE_MINT],\n      }),\n    );\n  }\n\n  return {\n    createInstructions,\n    cleanupInstructions,\n    tokenAccountAddresses,\n  };\n}\n\n/**\n * Retrieves the current transfer fee configuration for a given token mint based on the current epoch.\n *\n * This function checks the mint's transfer fee configuration and returns the appropriate fee\n * structure (older or newer) depending on the current epoch. If no transfer fee configuration is found,\n * it returns `undefined`.\n *\n * @param {Mint} mint - The mint account of the token, which may include transfer fee extensions.\n * @param {bigint} currentEpoch - The current epoch to determine the applicable transfer fee.\n *\n * @returns {TransferFee | undefined} - The transfer fee configuration for the given mint, or `undefined` if no transfer fee is configured.\n */\nexport function getCurrentTransferFee(\n  mint: MaybeAccount<Mint> | Account<Mint> | null,\n  currentEpoch: bigint,\n): TransferFee | undefined {\n  if (\n    mint == null ||\n    (\"exists\" in mint && !mint.exists) ||\n    mint.data.extensions.__option === \"None\"\n  ) {\n    return undefined;\n  }\n  const feeConfig = mint.data.extensions.value.find(\n    (x) => x.__kind === \"TransferFeeConfig\",\n  );\n  if (feeConfig == null) {\n    return undefined;\n  }\n  const transferFee =\n    currentEpoch >= feeConfig.newerTransferFee.epoch\n      ? feeConfig.newerTransferFee\n      : feeConfig.olderTransferFee;\n  return {\n    feeBps: transferFee.transferFeeBasisPoints,\n    maxFee: transferFee.maximumFee,\n  };\n}\n","import type {\n  CollectFeesQuote,\n  CollectRewardsQuote,\n} from \"@orca-so/whirlpools-core\";\nimport {\n  collectFeesQuote,\n  collectRewardsQuote,\n  getTickArrayStartTickIndex,\n  getTickIndexInArray,\n} from \"@orca-so/whirlpools-core\";\nimport type {\n  Rpc,\n  GetAccountInfoApi,\n  Address,\n  IInstruction,\n  TransactionSigner,\n  GetMultipleAccountsApi,\n  GetMinimumBalanceForRentExemptionApi,\n  GetEpochInfoApi,\n} from \"@solana/web3.js\";\nimport { DEFAULT_ADDRESS, FUNDER } from \"./config\";\nimport {\n  fetchAllTickArray,\n  fetchPosition,\n  fetchWhirlpool,\n  getCollectFeesV2Instruction,\n  getCollectRewardV2Instruction,\n  getPositionAddress,\n  getTickArrayAddress,\n  getUpdateFeesAndRewardsInstruction,\n} from \"@orca-so/whirlpools-client\";\nimport { findAssociatedTokenPda } from \"@solana-program/token\";\nimport {\n  getCurrentTransferFee,\n  prepareTokenAccountsInstructions,\n} from \"./token\";\nimport { fetchAllMaybeMint } from \"@solana-program/token-2022\";\nimport { MEMO_PROGRAM_ADDRESS } from \"@solana-program/memo\";\nimport assert from \"assert\";\n\n// TODO: Transfer hook\n\n/**\n * Represents the instructions and quotes for harvesting a position.\n */\nexport type HarvestPositionInstructions = {\n  /** A breakdown of the fees owed to the position owner, detailing the amounts for token A (`fee_owed_a`) and token B (`fee_owed_b`). */\n  feesQuote: CollectFeesQuote;\n\n  /** A breakdown of the rewards owed, detailing up to three reward tokens (`reward_owed_1`, `reward_owed_2`, and `reward_owed_3`). */\n  rewardsQuote: CollectRewardsQuote;\n\n  /** A list of instructions required to harvest the position. */\n  instructions: IInstruction[];\n};\n\n/**\n * This function creates a set of instructions that collect any accumulated fees and rewards from a position.\n * The liquidity remains in place, and the position stays open.\n *\n * @param {SolanaRpc} rpc\n *    A Solana RPC client used to interact with the blockchain.\n * @param {Address} positionMintAddress\n *    The position mint address you want to harvest fees and rewards from.\n * @param {TransactionSigner} [authority=FUNDER]\n *    The account that authorizes the transaction. Defaults to a predefined funder.\n *\n * @returns {Promise<HarvestPositionInstructions>}\n *    A promise that resolves to an object containing the instructions, fees, and rewards quotes.\n * @example\n * import { harvestPositionInstructions } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner();\n * await devnetRpc.requestAirdrop(wallet.address, lamports(1000000000n)).send();\n *\n * const positionMint = \"POSITION_MINT\";\n *\n * const { feesQuote, rewardsQuote, instructions } = await harvestPositionInstructions(\n *   devnetRpc,\n *   positionMint,\n *   wallet\n * );\n */\nexport async function harvestPositionInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi &\n      GetEpochInfoApi\n  >,\n  positionMintAddress: Address,\n  authority: TransactionSigner = FUNDER,\n): Promise<HarvestPositionInstructions> {\n  assert(\n    authority.address !== DEFAULT_ADDRESS,\n    \"Either supply an authority or set the default funder\",\n  );\n\n  const currentEpoch = await rpc.getEpochInfo().send();\n  const positionAddress = await getPositionAddress(positionMintAddress);\n  const position = await fetchPosition(rpc, positionAddress[0]);\n  const whirlpool = await fetchWhirlpool(rpc, position.data.whirlpool);\n  const [mintA, mintB, positionMint, ...rewardMints] = await fetchAllMaybeMint(\n    rpc,\n    [\n      whirlpool.data.tokenMintA,\n      whirlpool.data.tokenMintB,\n      positionMintAddress,\n      ...whirlpool.data.rewardInfos\n        .map((x) => x.mint)\n        .filter((x) => x !== DEFAULT_ADDRESS),\n    ],\n  );\n\n  assert(mintA.exists, \"Token A not found\");\n  assert(mintB.exists, \"Token B not found\");\n  assert(positionMint.exists, \"Position mint not found\");\n\n  const lowerTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickLowerIndex,\n    whirlpool.data.tickSpacing,\n  );\n  const upperTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickUpperIndex,\n    whirlpool.data.tickSpacing,\n  );\n\n  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] =\n    await Promise.all([\n      findAssociatedTokenPda({\n        owner: authority.address,\n        mint: positionMintAddress,\n        tokenProgram: positionMint.programAddress,\n      }).then((x) => x[0]),\n      getTickArrayAddress(whirlpool.address, lowerTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n      getTickArrayAddress(whirlpool.address, upperTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n    ]);\n\n  const [lowerTickArray, upperTickArray] = await fetchAllTickArray(rpc, [\n    lowerTickArrayAddress,\n    upperTickArrayAddress,\n  ]);\n\n  const lowerTick =\n    lowerTickArray.data.ticks[\n      getTickIndexInArray(\n        position.data.tickLowerIndex,\n        lowerTickArrayStartIndex,\n        whirlpool.data.tickSpacing,\n      )\n    ];\n  const upperTick =\n    upperTickArray.data.ticks[\n      getTickIndexInArray(\n        position.data.tickUpperIndex,\n        upperTickArrayStartIndex,\n        whirlpool.data.tickSpacing,\n      )\n    ];\n\n  const feesQuote = collectFeesQuote(\n    whirlpool.data,\n    position.data,\n    lowerTick,\n    upperTick,\n    getCurrentTransferFee(mintA, currentEpoch.epoch),\n    getCurrentTransferFee(mintB, currentEpoch.epoch),\n  );\n  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1000));\n  const rewardsQuote = collectRewardsQuote(\n    whirlpool.data,\n    position.data,\n    lowerTick,\n    upperTick,\n    currentUnixTimestamp,\n    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),\n    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),\n    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch),\n  );\n\n  const requiredMints: Address[] = [];\n  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {\n    requiredMints.push(whirlpool.data.tokenMintA);\n    requiredMints.push(whirlpool.data.tokenMintB);\n  }\n  if (rewardsQuote.rewards[0].rewardsOwed > 0n) {\n    requiredMints.push(whirlpool.data.rewardInfos[0].mint);\n  }\n  if (rewardsQuote.rewards[1].rewardsOwed > 0n) {\n    requiredMints.push(whirlpool.data.rewardInfos[1].mint);\n  }\n  if (rewardsQuote.rewards[2].rewardsOwed > 0n) {\n    requiredMints.push(whirlpool.data.rewardInfos[2].mint);\n  }\n\n  const { createInstructions, cleanupInstructions, tokenAccountAddresses } =\n    await prepareTokenAccountsInstructions(rpc, authority, requiredMints);\n\n  const instructions: IInstruction[] = [];\n  instructions.push(...createInstructions);\n\n  if (position.data.liquidity > 0n) {\n    instructions.push(\n      getUpdateFeesAndRewardsInstruction({\n        whirlpool: whirlpool.address,\n        position: positionAddress[0],\n        tickArrayLower: lowerTickArrayAddress,\n        tickArrayUpper: upperTickArrayAddress,\n      }),\n    );\n  }\n\n  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {\n    instructions.push(\n      getCollectFeesV2Instruction({\n        whirlpool: whirlpool.address,\n        positionAuthority: authority,\n        position: positionAddress[0],\n        positionTokenAccount,\n        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n        tokenVaultA: whirlpool.data.tokenVaultA,\n        tokenVaultB: whirlpool.data.tokenVaultB,\n        tokenMintA: whirlpool.data.tokenMintA,\n        tokenMintB: whirlpool.data.tokenMintB,\n        tokenProgramA: mintA.programAddress,\n        tokenProgramB: mintB.programAddress,\n        memoProgram: MEMO_PROGRAM_ADDRESS,\n        remainingAccountsInfo: null,\n      }),\n    );\n  }\n\n  for (let i = 0; i < rewardsQuote.rewards.length; i++) {\n    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {\n      continue;\n    }\n    const rewardMint = rewardMints[i];\n    assert(rewardMint.exists, `Reward mint ${i} not found`);\n    instructions.push(\n      getCollectRewardV2Instruction({\n        whirlpool: whirlpool.address,\n        positionAuthority: authority,\n        position: positionAddress[0],\n        positionTokenAccount,\n        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],\n        rewardVault: whirlpool.data.rewardInfos[i].vault,\n        rewardIndex: i,\n        rewardMint: rewardMint.address,\n        rewardTokenProgram: rewardMint.programAddress,\n        memoProgram: MEMO_PROGRAM_ADDRESS,\n        remainingAccountsInfo: null,\n      }),\n    );\n  }\n\n  instructions.push(...cleanupInstructions);\n\n  return {\n    feesQuote,\n    rewardsQuote,\n    instructions,\n  };\n}\n","import type { Whirlpool } from \"@orca-so/whirlpools-client\";\nimport {\n  fetchAllMaybeTickArray,\n  fetchPosition,\n  fetchWhirlpool,\n  getIncreaseLiquidityV2Instruction,\n  getInitializeTickArrayInstruction,\n  getOpenPositionWithTokenExtensionsInstruction,\n  getPositionAddress,\n  getTickArrayAddress,\n  getTickArraySize,\n} from \"@orca-so/whirlpools-client\";\nimport type {\n  IncreaseLiquidityQuote,\n  TickRange,\n  TransferFee,\n} from \"@orca-so/whirlpools-core\";\nimport {\n  _MAX_TICK_INDEX,\n  _MIN_TICK_INDEX,\n  getFullRangeTickIndexes,\n  getTickArrayStartTickIndex,\n  increaseLiquidityQuote,\n  increaseLiquidityQuoteA,\n  increaseLiquidityQuoteB,\n  priceToTickIndex,\n  getInitializableTickIndex,\n  orderTickIndexes,\n} from \"@orca-so/whirlpools-core\";\nimport type {\n  Account,\n  Address,\n  GetAccountInfoApi,\n  GetMinimumBalanceForRentExemptionApi,\n  GetMultipleAccountsApi,\n  IInstruction,\n  LamportsUnsafeBeyond2Pow53Minus1,\n  Rpc,\n  TransactionSigner,\n} from \"@solana/web3.js\";\nimport { address, generateKeyPairSigner, lamports } from \"@solana/web3.js\";\nimport {\n  DEFAULT_ADDRESS,\n  FUNDER,\n  SLIPPAGE_TOLERANCE_BPS,\n  SPLASH_POOL_TICK_SPACING,\n} from \"./config\";\nimport {\n  ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  findAssociatedTokenPda,\n} from \"@solana-program/token\";\nimport {\n  getCurrentTransferFee,\n  prepareTokenAccountsInstructions,\n} from \"./token\";\nimport type { Mint } from \"@solana-program/token-2022\";\nimport {\n  fetchAllMint,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport { MEMO_PROGRAM_ADDRESS } from \"@solana-program/memo\";\nimport assert from \"assert\";\n\n// TODO: allow specify number as well as bigint\n// TODO: transfer hook\n\n/**\n * Represents the parameters for increasing liquidity.\n * You must choose only one of the properties (`liquidity`, `tokenA`, or `tokenB`).\n * The SDK will compute the other two based on the input provided.\n */\nexport type IncreaseLiquidityQuoteParam =\n  | {\n      /** The amount of liquidity to increase. */\n      liquidity: bigint;\n    }\n  | {\n      /** The amount of Token A to add. */\n      tokenA: bigint;\n    }\n  | {\n      /** The amount of Token B to add. */\n      tokenB: bigint;\n    };\n\n/**\n * Represents the instructions and quote for increasing liquidity in a position.\n */\nexport type IncreaseLiquidityInstructions = {\n  /** The quote object with details about the increase in liquidity, including the liquidity delta, estimated tokens, and maximum token amounts based on slippage tolerance. */\n  quote: IncreaseLiquidityQuote;\n\n  /** The initialization cost for liquidity in lamports. */\n  initializationCost: LamportsUnsafeBeyond2Pow53Minus1;\n\n  /** The mint address of the position NFT. */\n  positionMint: Address;\n\n  /** List of Solana transaction instructions to execute. */\n  instructions: IInstruction[];\n};\n\nfunction getIncreaseLiquidityQuote(\n  param: IncreaseLiquidityQuoteParam,\n  pool: Whirlpool,\n  tickRange: TickRange,\n  slippageToleranceBps: number,\n  transferFeeA: TransferFee | undefined,\n  transferFeeB: TransferFee | undefined,\n): IncreaseLiquidityQuote {\n  if (\"liquidity\" in param) {\n    return increaseLiquidityQuote(\n      param.liquidity,\n      slippageToleranceBps,\n      pool.sqrtPrice,\n      tickRange.tickLowerIndex,\n      tickRange.tickUpperIndex,\n      transferFeeA,\n      transferFeeB,\n    );\n  } else if (\"tokenA\" in param) {\n    return increaseLiquidityQuoteA(\n      param.tokenA,\n      slippageToleranceBps,\n      pool.sqrtPrice,\n      tickRange.tickLowerIndex,\n      tickRange.tickUpperIndex,\n      transferFeeA,\n      transferFeeB,\n    );\n  } else {\n    return increaseLiquidityQuoteB(\n      param.tokenB,\n      slippageToleranceBps,\n      pool.sqrtPrice,\n      tickRange.tickLowerIndex,\n      tickRange.tickUpperIndex,\n      transferFeeA,\n      transferFeeB,\n    );\n  }\n}\n\n/**\n * Generates instructions to increase liquidity for an existing position.\n *\n * @param {SolanaRpc} rpc - The Solana RPC client.\n * @param {Address} positionMintAddress - The mint address of the NFT that represents the position.\n * @param {IncreaseLiquidityQuoteParam} param - The parameters for adding liquidity. Can specify liquidity, Token A, or Token B amounts.\n * @param {number} [slippageToleranceBps=SLIPPAGE_TOLERANCE_BPS] - The maximum acceptable slippage, in basis points (BPS).\n * @param {TransactionSigner} [authority=FUNDER] - The account that authorizes the transaction.\n * @returns {Promise<IncreaseLiquidityInstructions>} - Instructions and quote for increasing liquidity.\n *\n * @example\n * import { increaseLiquidityInstructions } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner();\n * await devnetRpc.requestAirdrop(wallet.address, lamports(1000000000n)).send();\n *\n * const positionMint = \"POSITION_MINT\";\n *\n * const param = { tokenA: 1_000_000n };\n *\n * const { quote, instructions, initializationCost } = await increaseLiquidityInstructions(\n *   devnetRpc,\n *   positionMint,\n *   param,\n *   100,\n *   wallet\n * );\n */\nexport async function increaseLiquidityInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi\n  >,\n  positionMintAddress: Address,\n  param: IncreaseLiquidityQuoteParam,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  authority: TransactionSigner = FUNDER,\n): Promise<IncreaseLiquidityInstructions> {\n  assert(\n    authority.address !== DEFAULT_ADDRESS,\n    \"Either supply the authority or set the default funder\",\n  );\n\n  const positionAddress = await getPositionAddress(positionMintAddress);\n  const position = await fetchPosition(rpc, positionAddress[0]);\n  const whirlpool = await fetchWhirlpool(rpc, position.data.whirlpool);\n\n  const currentEpoch = await rpc.getEpochInfo().send();\n  const [mintA, mintB, positionMint] = await fetchAllMint(rpc, [\n    whirlpool.data.tokenMintA,\n    whirlpool.data.tokenMintB,\n    positionMintAddress,\n  ]);\n  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);\n  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);\n\n  const quote = getIncreaseLiquidityQuote(\n    param,\n    whirlpool.data,\n    position.data,\n    slippageToleranceBps,\n    transferFeeA,\n    transferFeeB,\n  );\n  const instructions: IInstruction[] = [];\n\n  const lowerTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickLowerIndex,\n    whirlpool.data.tickSpacing,\n  );\n  const upperTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickUpperIndex,\n    whirlpool.data.tickSpacing,\n  );\n\n  const [positionTokenAccount, tickArrayLower, tickArrayUpper] =\n    await Promise.all([\n      findAssociatedTokenPda({\n        owner: authority.address,\n        mint: positionMintAddress,\n        tokenProgram: positionMint.programAddress,\n      }).then((x) => x[0]),\n      getTickArrayAddress(whirlpool.address, lowerTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n      getTickArrayAddress(whirlpool.address, upperTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n    ]);\n\n  const { createInstructions, cleanupInstructions, tokenAccountAddresses } =\n    await prepareTokenAccountsInstructions(rpc, authority, {\n      [whirlpool.data.tokenMintA]: quote.tokenMaxA,\n      [whirlpool.data.tokenMintB]: quote.tokenMaxB,\n    });\n\n  instructions.push(...createInstructions);\n\n  // Since position exists tick arrays must also already exist\n\n  instructions.push(\n    getIncreaseLiquidityV2Instruction({\n      whirlpool: whirlpool.address,\n      positionAuthority: authority,\n      position: position.address,\n      positionTokenAccount,\n      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n      tokenVaultA: whirlpool.data.tokenVaultA,\n      tokenVaultB: whirlpool.data.tokenVaultB,\n      tokenMintA: whirlpool.data.tokenMintA,\n      tokenMintB: whirlpool.data.tokenMintB,\n      tokenProgramA: mintA.programAddress,\n      tokenProgramB: mintB.programAddress,\n      tickArrayLower,\n      tickArrayUpper,\n      liquidityAmount: quote.liquidityDelta,\n      tokenMaxA: quote.tokenMaxA,\n      tokenMaxB: quote.tokenMaxB,\n      memoProgram: MEMO_PROGRAM_ADDRESS,\n      remainingAccountsInfo: null,\n    }),\n  );\n\n  instructions.push(...cleanupInstructions);\n\n  return {\n    quote,\n    instructions,\n    positionMint: positionMintAddress,\n    initializationCost: lamports(0n),\n  };\n}\n\nasync function internalOpenPositionInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi\n  >,\n  whirlpool: Account<Whirlpool>,\n  param: IncreaseLiquidityQuoteParam,\n  lowerTickIndex: number,\n  upperTickIndex: number,\n  mintA: Account<Mint>,\n  mintB: Account<Mint>,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  funder: TransactionSigner = FUNDER,\n): Promise<IncreaseLiquidityInstructions> {\n  assert(\n    funder.address !== DEFAULT_ADDRESS,\n    \"Either supply a funder or set the default funder\",\n  );\n  const instructions: IInstruction[] = [];\n  let nonReclaimableStateSpace = 0;\n\n  const initializableLowerTickIndex = getInitializableTickIndex(\n    lowerTickIndex,\n    whirlpool.data.tickSpacing,\n    false,\n  );\n  const initializableUpperTickIndex = getInitializableTickIndex(\n    upperTickIndex,\n    whirlpool.data.tickSpacing,\n    true,\n  );\n  const tickRange = orderTickIndexes(\n    initializableLowerTickIndex,\n    initializableUpperTickIndex,\n  );\n\n  const currentEpoch = await rpc.getEpochInfo().send();\n  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);\n  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);\n\n  const quote = getIncreaseLiquidityQuote(\n    param,\n    whirlpool.data,\n    tickRange,\n    slippageToleranceBps,\n    transferFeeA,\n    transferFeeB,\n  );\n\n  const positionMint = await generateKeyPairSigner();\n\n  const lowerTickArrayIndex = getTickArrayStartTickIndex(\n    tickRange.tickLowerIndex,\n    whirlpool.data.tickSpacing,\n  );\n  const upperTickArrayIndex = getTickArrayStartTickIndex(\n    tickRange.tickUpperIndex,\n    whirlpool.data.tickSpacing,\n  );\n\n  const [\n    positionAddress,\n    positionTokenAccount,\n    lowerTickArrayAddress,\n    upperTickArrayAddress,\n  ] = await Promise.all([\n    getPositionAddress(positionMint.address),\n    findAssociatedTokenPda({\n      owner: funder.address,\n      mint: positionMint.address,\n      tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,\n    }).then((x) => x[0]),\n    getTickArrayAddress(whirlpool.address, lowerTickArrayIndex).then(\n      (x) => x[0],\n    ),\n    getTickArrayAddress(whirlpool.address, upperTickArrayIndex).then(\n      (x) => x[0],\n    ),\n  ]);\n\n  const { createInstructions, cleanupInstructions, tokenAccountAddresses } =\n    await prepareTokenAccountsInstructions(rpc, funder, {\n      [whirlpool.data.tokenMintA]: quote.tokenMaxA,\n      [whirlpool.data.tokenMintB]: quote.tokenMaxB,\n    });\n\n  instructions.push(...createInstructions);\n\n  const [lowerTickArray, upperTickArray] = await fetchAllMaybeTickArray(rpc, [\n    lowerTickArrayAddress,\n    upperTickArrayAddress,\n  ]);\n\n  if (!lowerTickArray.exists) {\n    instructions.push(\n      getInitializeTickArrayInstruction({\n        whirlpool: whirlpool.address,\n        funder,\n        tickArray: lowerTickArrayAddress,\n        startTickIndex: lowerTickIndex,\n      }),\n    );\n    nonReclaimableStateSpace += getTickArraySize();\n  }\n\n  if (!upperTickArray.exists && lowerTickArrayIndex !== upperTickArrayIndex) {\n    instructions.push(\n      getInitializeTickArrayInstruction({\n        whirlpool: whirlpool.address,\n        funder,\n        tickArray: upperTickArrayAddress,\n        startTickIndex: upperTickIndex,\n      }),\n    );\n    nonReclaimableStateSpace += getTickArraySize();\n  }\n\n  instructions.push(\n    getOpenPositionWithTokenExtensionsInstruction({\n      funder,\n      owner: funder.address,\n      position: positionAddress[0],\n      positionMint,\n      positionTokenAccount,\n      whirlpool: whirlpool.address,\n      associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n      tickLowerIndex: tickRange.tickLowerIndex,\n      tickUpperIndex: tickRange.tickUpperIndex,\n      token2022Program: TOKEN_2022_PROGRAM_ADDRESS,\n      metadataUpdateAuth: address(\n        \"3axbTs2z5GBy6usVbNVoqEgZMng3vZvMnAoX29BFfwhr\",\n      ),\n      withTokenMetadataExtension: true,\n    }),\n  );\n\n  instructions.push(\n    getIncreaseLiquidityV2Instruction({\n      whirlpool: whirlpool.address,\n      positionAuthority: funder,\n      position: positionAddress[0],\n      positionTokenAccount,\n      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n      tokenVaultA: whirlpool.data.tokenVaultA,\n      tokenVaultB: whirlpool.data.tokenVaultB,\n      tokenMintA: whirlpool.data.tokenMintA,\n      tokenMintB: whirlpool.data.tokenMintB,\n      tokenProgramA: mintA.programAddress,\n      tokenProgramB: mintB.programAddress,\n      tickArrayLower: lowerTickArrayAddress,\n      tickArrayUpper: upperTickArrayAddress,\n      liquidityAmount: quote.liquidityDelta,\n      tokenMaxA: quote.tokenMaxA,\n      tokenMaxB: quote.tokenMaxB,\n      memoProgram: MEMO_PROGRAM_ADDRESS,\n      remainingAccountsInfo: null,\n    }),\n  );\n\n  instructions.push(...cleanupInstructions);\n\n  let nonRefundableRent = lamports(0n);\n  if (nonReclaimableStateSpace > 0) {\n    nonRefundableRent = await rpc\n      .getMinimumBalanceForRentExemption(BigInt(nonReclaimableStateSpace))\n      .send();\n  }\n\n  return {\n    instructions,\n    quote,\n    positionMint: positionMint.address,\n    initializationCost: nonRefundableRent,\n  };\n}\n\n/**\n * Opens a full-range position for a pool, typically used for Splash Pools or other full-range liquidity provisioning.\n *\n * @param {SolanaRpc} rpc - The Solana RPC client.\n * @param {Address} poolAddress - The address of the liquidity pool.\n * @param {IncreaseLiquidityQuoteParam} param - The parameters for adding liquidity, where one of `liquidity`, `tokenA`, or `tokenB` must be specified. The SDK will compute the others.\n * @param {number} [slippageToleranceBps=SLIPPAGE_TOLERANCE_BPS] - The maximum acceptable slippage, in basis points (BPS).\n * @param {TransactionSigner} [funder=FUNDER] - The account funding the transaction.\n * @returns {Promise<IncreaseLiquidityInstructions>} - Instructions and quote for opening a full-range position.\n *\n * @example\n * import { openFullRangePositionInstructions } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner();\n * await devnetRpc.requestAirdrop(wallet.address, lamports(1000000000n)).send();\n *\n * const poolAddress = \"POOL_ADDRESS\";\n *\n * const param = { tokenA: 1_000_000n };\n *\n * const { quote, instructions, initializationCost } = await openFullRangePositionInstructions(\n *   devnetRpc,\n *   poolAddress,\n *   param,\n *   100,\n *   wallet\n * );\n */\nexport async function openFullRangePositionInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi\n  >,\n  poolAddress: Address,\n  param: IncreaseLiquidityQuoteParam,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  funder: TransactionSigner = FUNDER,\n): Promise<IncreaseLiquidityInstructions> {\n  const whirlpool = await fetchWhirlpool(rpc, poolAddress);\n  const tickRange = getFullRangeTickIndexes(whirlpool.data.tickSpacing);\n  const [mintA, mintB] = await fetchAllMint(rpc, [\n    whirlpool.data.tokenMintA,\n    whirlpool.data.tokenMintB,\n  ]);\n  return internalOpenPositionInstructions(\n    rpc,\n    whirlpool,\n    param,\n    tickRange.tickLowerIndex,\n    tickRange.tickUpperIndex,\n    mintA,\n    mintB,\n    slippageToleranceBps,\n    funder,\n  );\n}\n\n/**\n * Opens a new position in a concentrated liquidity pool within a specific price range.\n * This function allows you to provide liquidity for the specified range of prices and adjust liquidity parameters accordingly.\n *\n * **Note:** This function cannot be used with Splash Pools.\n *\n * @param {SolanaRpc} rpc - A Solana RPC client used to interact with the blockchain.\n * @param {Address} poolAddress - The address of the liquidity pool where the position will be opened.\n * @param {IncreaseLiquidityQuoteParam} param - The parameters for increasing liquidity, where you must choose one (`liquidity`, `tokenA`, or `tokenB`). The SDK will compute the other two.\n * @param {number} lowerPrice - The lower bound of the price range for the position.\n * @param {number} upperPrice - The upper bound of the price range for the position.\n * @param {number} [slippageToleranceBps=SLIPPAGE_TOLERANCE_BPS] - The slippage tolerance for adding liquidity, in basis points (BPS).\n * @param {TransactionSigner} [funder=FUNDER] - The account funding the transaction.\n *\n * @returns {Promise<IncreaseLiquidityInstructions>} A promise that resolves to an object containing liquidity information and the list of instructions needed to open the position.\n *\n * @example\n * import { openPositionInstructions } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner();\n * await devnetRpc.requestAirdrop(wallet.address, lamports(1000000000n)).send();\n *\n * const poolAddress = \"POOL_ADDRESS\";\n *\n * const param = { tokenA: 1_000_000n };\n * const lowerPrice = 0.00005;\n * const upperPrice = 0.00015;\n *\n * const { quote, instructions, initializationCost } = await openPositionInstructions(\n *   devnetRpc,\n *   poolAddress,\n *   param,\n *   lowerPrice,\n *   upperPrice,\n *   100,\n *   wallet\n * );\n */\nexport async function openPositionInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi\n  >,\n  poolAddress: Address,\n  param: IncreaseLiquidityQuoteParam,\n  lowerPrice: number,\n  upperPrice: number,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  funder: TransactionSigner = FUNDER,\n): Promise<IncreaseLiquidityInstructions> {\n  const whirlpool = await fetchWhirlpool(rpc, poolAddress);\n  assert(\n    whirlpool.data.tickSpacing !== SPLASH_POOL_TICK_SPACING,\n    \"Splash pools only support full range positions\",\n  );\n  const [mintA, mintB] = await fetchAllMint(rpc, [\n    whirlpool.data.tokenMintA,\n    whirlpool.data.tokenMintB,\n  ]);\n  const decimalsA = mintA.data.decimals;\n  const decimalsB = mintB.data.decimals;\n  const lowerTickIndex = priceToTickIndex(lowerPrice, decimalsA, decimalsB);\n  const lowerInitializableTickIndex = getInitializableTickIndex(\n    lowerTickIndex,\n    whirlpool.data.tickSpacing,\n  );\n  const upperTickIndex = priceToTickIndex(upperPrice, decimalsA, decimalsB);\n  const upperInitializableTickIndex = getInitializableTickIndex(\n    upperTickIndex,\n    whirlpool.data.tickSpacing,\n  );\n  return internalOpenPositionInstructions(\n    rpc,\n    whirlpool,\n    param,\n    lowerInitializableTickIndex,\n    upperInitializableTickIndex,\n    mintA,\n    mintB,\n    slippageToleranceBps,\n    funder,\n  );\n}\n","import type { Whirlpool } from \"@orca-so/whirlpools-client\";\nimport {\n  getFeeTierAddress,\n  getWhirlpoolAddress,\n  fetchWhirlpoolsConfig,\n  fetchFeeTier,\n  fetchMaybeWhirlpool,\n  fetchAllMaybeWhirlpool,\n  fetchAllFeeTierWithFilter,\n  feeTierWhirlpoolsConfigFilter,\n} from \"@orca-so/whirlpools-client\";\nimport type {\n  Rpc,\n  GetAccountInfoApi,\n  GetMultipleAccountsApi,\n  Address,\n  GetProgramAccountsApi,\n} from \"@solana/web3.js\";\nimport { SPLASH_POOL_TICK_SPACING, WHIRLPOOLS_CONFIG_ADDRESS } from \"./config\";\n\n/**\n * Type representing a pool that is not yet initialized.\n */\nexport type InitializablePool = {\n  /** Indicates the pool is not initialized. */\n  initialized: false;\n} & Pick<\n  Whirlpool,\n  | \"whirlpoolsConfig\"\n  | \"tickSpacing\"\n  | \"feeRate\"\n  | \"protocolFeeRate\"\n  | \"tokenMintA\"\n  | \"tokenMintB\"\n>;\n\n/**\n * Type representing a pool that has been initialized.\n * Extends the `Whirlpool` type, inheriting all its properties.\n */\nexport type InitializedPool = {\n  /** Indicates the pool is initialized. */\n  initialized: true;\n} & Whirlpool;\n\n/**\n * Combined type representing both initialized and uninitialized pools.\n */\nexport type PoolInfo = (InitializablePool | InitializedPool) & {\n  /** The address of the pool. */\n  address: Address;\n};\n\n/**\n * Fetches the details of a specific Splash Pool.\n *\n * @param {SolanaRpc} rpc - The Solana RPC client.\n * @param {Address} tokenMintOne - The first token mint address in the pool.\n * @param {Address} tokenMintTwo - The second token mint address in the pool.\n * @returns {Promise<PoolInfo>} - A promise that resolves to the pool information, which includes whether the pool is initialized or not.\n *\n * @example\n * import { fetchSplashPool } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner();\n * await devnetRpc.requestAirdrop(wallet.address, lamports(1000000000n)).send();\n *\n * const tokenMintOne = \"TOKEN_MINT_ONE\";\n * const tokenMintTwo = \"TOKEN_MINT_TWO\";\n *\n * const poolInfo = await fetchSplashPool(\n *   devnetRpc,\n *   tokenMintOne,\n *   tokenMintTwo\n * );\n */\nexport async function fetchSplashPool(\n  rpc: Rpc<GetAccountInfoApi>,\n  tokenMintOne: Address,\n  tokenMintTwo: Address,\n): Promise<PoolInfo> {\n  return fetchConcentratedLiquidityPool(\n    rpc,\n    tokenMintOne,\n    tokenMintTwo,\n    SPLASH_POOL_TICK_SPACING,\n  );\n}\n\n/**\n * Fetches the details of a specific Concentrated Liquidity Pool.\n *\n * @param {SolanaRpc} rpc - The Solana RPC client.\n * @param {Address} tokenMintOne - The first token mint address in the pool.\n * @param {Address} tokenMintTwo - The second token mint address in the pool.\n * @param {number} tickSpacing - The tick spacing of the pool.\n * @returns {Promise<PoolInfo>} - A promise that resolves to the pool information, which includes whether the pool is initialized or not.\n *\n * @example\n * import { fetchPool } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner();\n * await devnetRpc.requestAirdrop(wallet.address, lamports(1000000000n)).send();\n *\n * const tokenMintOne = \"TOKEN_MINT_ONE\";\n * const tokenMintTwo = \"TOKEN_MINT_TWO\";\n * const tickSpacing = 64;\n *\n * const poolInfo = await fetchPool(\n *   devnetRpc,\n *   tokenMintOne,\n *   tokenMintTwo,\n *   tickSpacing\n * );\n */\nexport async function fetchConcentratedLiquidityPool(\n  rpc: Rpc<GetAccountInfoApi>,\n  tokenMintOne: Address,\n  tokenMintTwo: Address,\n  tickSpacing: number,\n): Promise<PoolInfo> {\n  const [tokenMintA, tokenMintB] =\n    Buffer.from(tokenMintOne) < Buffer.from(tokenMintTwo)\n      ? [tokenMintOne, tokenMintTwo]\n      : [tokenMintTwo, tokenMintOne];\n  const feeTierAddress = await getFeeTierAddress(\n    WHIRLPOOLS_CONFIG_ADDRESS,\n    tickSpacing,\n  ).then((x) => x[0]);\n  const poolAddress = await getWhirlpoolAddress(\n    WHIRLPOOLS_CONFIG_ADDRESS,\n    tokenMintA,\n    tokenMintB,\n    tickSpacing,\n  ).then((x) => x[0]);\n\n  // TODO: this is multiple rpc calls. Can we do it in one?\n  const [configAccount, feeTierAccount, poolAccount] = await Promise.all([\n    fetchWhirlpoolsConfig(rpc, WHIRLPOOLS_CONFIG_ADDRESS),\n    fetchFeeTier(rpc, feeTierAddress),\n    fetchMaybeWhirlpool(rpc, poolAddress),\n  ]);\n\n  if (poolAccount.exists) {\n    return {\n      initialized: true,\n      address: poolAddress,\n      ...poolAccount.data,\n    };\n  } else {\n    return {\n      initialized: false,\n      address: poolAddress,\n      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,\n      tickSpacing,\n      feeRate: feeTierAccount.data.defaultFeeRate,\n      protocolFeeRate: configAccount.data.defaultProtocolFeeRate,\n      tokenMintA: tokenMintA,\n      tokenMintB: tokenMintB,\n    };\n  }\n}\n\n/**\n * Fetches all possible liquidity pools between two token mints in Orca Whirlpools.\n * If a pool does not exist, it creates a placeholder account for the uninitialized pool with default data\n *\n * @param {SolanaRpc} rpc - The Solana RPC client.\n * @param {Address} tokenMintOne - The first token mint address in the pool.\n * @param {Address} tokenMintTwo - The second token mint address in the pool.\n * @returns {Promise<PoolInfo[]>} - A promise that resolves to an array of pool information for each pool between the two tokens.\n *\n * @example\n * import { fetchWhirlpools } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner();\n * await devnetRpc.requestAirdrop(wallet.address, lamports(1000000000n)).send();\n *\n * const tokenMintOne = \"TOKEN_MINT_ONE\";\n * const tokenMintTwo = \"TOKEN_MINT_TWO\";\n *\n * const pools = await fetchWhirlpools(\n *   devnetRpc,\n *   tokenMintOne,\n *   tokenMintTwo\n * );\n */\nexport async function fetchWhirlpools(\n  rpc: Rpc<GetAccountInfoApi & GetMultipleAccountsApi & GetProgramAccountsApi>,\n  tokenMintOne: Address,\n  tokenMintTwo: Address,\n): Promise<PoolInfo[]> {\n  const [tokenMintA, tokenMintB] =\n    Buffer.from(tokenMintOne) < Buffer.from(tokenMintTwo)\n      ? [tokenMintOne, tokenMintTwo]\n      : [tokenMintTwo, tokenMintOne];\n\n  const feeTierAccounts = await fetchAllFeeTierWithFilter(\n    rpc,\n    feeTierWhirlpoolsConfigFilter(WHIRLPOOLS_CONFIG_ADDRESS),\n  );\n\n  const supportedTickSpacings = feeTierAccounts.map((x) => x.data.tickSpacing);\n\n  const poolAddresses = await Promise.all(\n    supportedTickSpacings.map((x) =>\n      getWhirlpoolAddress(\n        WHIRLPOOLS_CONFIG_ADDRESS,\n        tokenMintA,\n        tokenMintB,\n        x,\n      ).then((x) => x[0]),\n    ),\n  );\n\n  // TODO: this is multiple rpc calls. Can we do it in one?\n  const [configAccount, poolAccounts] = await Promise.all([\n    fetchWhirlpoolsConfig(rpc, WHIRLPOOLS_CONFIG_ADDRESS),\n    fetchAllMaybeWhirlpool(rpc, poolAddresses),\n  ]);\n\n  const pools: PoolInfo[] = [];\n  for (let i = 0; i < supportedTickSpacings.length; i++) {\n    const tickSpacing = supportedTickSpacings[i];\n    const feeTierAccount = feeTierAccounts[i];\n    const poolAccount = poolAccounts[i];\n    const poolAddress = poolAddresses[i];\n\n    if (poolAccount.exists) {\n      pools.push({\n        initialized: true,\n        address: poolAddress,\n        ...poolAccount.data,\n      });\n    } else {\n      pools.push({\n        initialized: false,\n        address: poolAddress,\n        whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,\n        tickSpacing,\n        feeRate: feeTierAccount.data.defaultFeeRate,\n        protocolFeeRate: configAccount.data.defaultProtocolFeeRate,\n        tokenMintA,\n        tokenMintB,\n      });\n    }\n  }\n  return pools;\n}\n","import type { Position, PositionBundle } from \"@orca-so/whirlpools-client\";\nimport {\n  fetchAllMaybePosition,\n  fetchAllMaybePositionBundle,\n  fetchAllPosition,\n  getBundledPositionAddress,\n  getPositionAddress,\n  getPositionBundleAddress,\n} from \"@orca-so/whirlpools-client\";\nimport { _POSITION_BUNDLE_SIZE } from \"@orca-so/whirlpools-core\";\nimport { getTokenDecoder, TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\nimport type {\n  Account,\n  Address,\n  GetMultipleAccountsApi,\n  GetTokenAccountsByOwnerApi,\n  Rpc,\n} from \"@solana/web3.js\";\nimport { getBase58Encoder } from \"@solana/web3.js\";\n\n/**\n * Represents a Position account.\n */\nexport type HydratedPosition = Account<Position> & {\n  isPositionBundle: false;\n};\n\n/**\n * Represents a Position Bundle account including its associated positions.\n */\nexport type HydratedPositionBundle = Account<PositionBundle> & {\n  positions: Account<Position>[];\n  isPositionBundle: true;\n};\n\n/**\n * Represents either a Position or Position Bundle account.\n */\nexport type PositionOrBundle = HydratedPosition | HydratedPositionBundle;\n\n/**\n * Represents a decoded Position or Position Bundle account.\n * Includes the token program address associated with the position.\n */\nexport type PositionData = PositionOrBundle & {\n  /** The token program associated with the position (either TOKEN_PROGRAM_ADDRESS or TOKEN_2022_PROGRAM_ADDRESS). */\n  tokenProgram: Address;\n};\n\nfunction getPositionInBundleAddresses(\n  positionBundle: PositionBundle,\n): Promise<Address>[] {\n  const buffer = Buffer.from(positionBundle.positionBitmap);\n  const positions: Promise<Address>[] = [];\n  for (let i = 0; i < _POSITION_BUNDLE_SIZE(); i++) {\n    const byteIndex = Math.floor(i / 8);\n    const bitIndex = i % 8;\n    if (buffer[byteIndex] & (1 << bitIndex)) {\n      positions.push(\n        getBundledPositionAddress(positionBundle.positionBundleMint, i).then(\n          (x) => x[0],\n        ),\n      );\n    }\n  }\n  return positions;\n}\n\n/**\n * Fetches all positions owned by a given wallet in the Orca Whirlpools.\n * It looks for token accounts owned by the wallet using both the TOKEN_PROGRAM_ADDRESS and TOKEN_2022_PROGRAM_ADDRESS.\n * For token accounts holding exactly 1 token (indicating a position or bundle), it fetches the corresponding position addresses,\n * decodes the accounts, and returns an array of position or bundle data.\n *\n * @param {SolanaRpc} rpc - The Solana RPC client used to fetch token accounts and multiple accounts.\n * @param {Address} owner - The wallet address whose positions you want to fetch.\n * @returns {Promise<PositionData[]>} - A promise that resolves to an array of decoded position data for the given owner.\n *\n * @example\n * import { fetchPositionsForOwner } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner();\n * await devnetRpc.requestAirdrop(wallet.address, lamports(1000000000n)).send();\n *\n * const positions = await fetchPositionsForOwner(devnetRpc, wallet.address);\n */\nexport async function fetchPositionsForOwner(\n  rpc: Rpc<GetTokenAccountsByOwnerApi & GetMultipleAccountsApi>,\n  owner: Address,\n): Promise<PositionData[]> {\n  const [tokenAccounts, token2022Accounts] = await Promise.all([\n    rpc\n      .getTokenAccountsByOwner(owner, { programId: TOKEN_PROGRAM_ADDRESS })\n      .send(),\n    rpc\n      .getTokenAccountsByOwner(owner, { programId: TOKEN_2022_PROGRAM_ADDRESS })\n      .send(),\n  ]);\n\n  const encoder = getBase58Encoder();\n  const decoder = getTokenDecoder();\n\n  const potentialTokens = [...tokenAccounts.value, ...token2022Accounts.value]\n    .map((x) => ({\n      ...decoder.decode(encoder.encode(x.account.data)),\n      owner: x.account.owner,\n    }))\n    .filter((x) => x.amount === 1n);\n\n  const positionAddresses = await Promise.all(\n    potentialTokens.map((x) => getPositionAddress(x.mint).then((x) => x[0])),\n  );\n\n  const positionBundleAddresses = await Promise.all(\n    potentialTokens.map((x) =>\n      getPositionBundleAddress(x.mint).then((x) => x[0]),\n    ),\n  );\n\n  // FIXME: need to batch if more than 100 position bundles?\n  const [positions, positionBundles] = await Promise.all([\n    fetchAllMaybePosition(rpc, positionAddresses),\n    fetchAllMaybePositionBundle(rpc, positionBundleAddresses),\n  ]);\n\n  const bundledPositionAddresses = await Promise.all(\n    positionBundles\n      .filter((x) => x.exists)\n      .flatMap((x) => getPositionInBundleAddresses(x.data)),\n  );\n\n  const bundledPositions = await fetchAllPosition(\n    rpc,\n    bundledPositionAddresses,\n  );\n  const bundledPositionMap = bundledPositions.reduce((acc, x) => {\n    const current = acc.get(x.data.positionMint) ?? [];\n    return acc.set(x.data.positionMint, [...current, x]);\n  }, new Map<Address, Account<Position>[]>());\n\n  const positionsOrBundles: PositionData[] = [];\n\n  for (let i = 0; i < potentialTokens.length; i++) {\n    const position = positions[i];\n    const positionBundle = positionBundles[i];\n    const token = potentialTokens[i];\n\n    if (position.exists) {\n      positionsOrBundles.push({\n        ...position,\n        tokenProgram: token.owner,\n        isPositionBundle: false,\n      });\n    }\n\n    if (positionBundle.exists) {\n      const positions =\n        bundledPositionMap.get(positionBundle.data.positionBundleMint) ?? [];\n      positionsOrBundles.push({\n        ...positionBundle,\n        positions,\n        tokenProgram: token.owner,\n        isPositionBundle: true,\n      });\n    }\n  }\n\n  return positionsOrBundles;\n}\n","import type {\n  Account,\n  Address,\n  GetAccountInfoApi,\n  GetMinimumBalanceForRentExemptionApi,\n  GetMultipleAccountsApi,\n  IInstruction,\n  Rpc,\n  TransactionSigner,\n} from \"@solana/web3.js\";\nimport { AccountRole, lamports } from \"@solana/web3.js\";\nimport { FUNDER, SLIPPAGE_TOLERANCE_BPS } from \"./config\";\nimport type {\n  ExactInSwapQuote,\n  ExactOutSwapQuote,\n  TickArrayFacade,\n  TransferFee,\n} from \"@orca-so/whirlpools-core\";\nimport {\n  _TICK_ARRAY_SIZE,\n  getTickArrayStartTickIndex,\n  swapQuoteByInputToken,\n  swapQuoteByOutputToken,\n} from \"@orca-so/whirlpools-core\";\nimport type { Whirlpool } from \"@orca-so/whirlpools-client\";\nimport {\n  AccountsType,\n  fetchAllMaybeTickArray,\n  fetchWhirlpool,\n  getOracleAddress,\n  getSwapV2Instruction,\n  getTickArrayAddress,\n} from \"@orca-so/whirlpools-client\";\nimport {\n  getCurrentTransferFee,\n  prepareTokenAccountsInstructions,\n} from \"./token\";\nimport { MEMO_PROGRAM_ADDRESS } from \"@solana-program/memo\";\nimport { fetchAllMint } from \"@solana-program/token-2022\";\n\n// TODO: allow specify number as well as bigint\n// TODO: transfer hook\n\n/**\n * Parameters for an exact input swap.\n */\nexport type ExactInParams = {\n  /** The exact amount of input tokens to be swapped. */\n  inputAmount: bigint;\n};\n\n/**\n * Parameters for an exact output swap.\n */\nexport type ExactOutParams = {\n  /** The exact amount of output tokens to be received from the swap. */\n  outputAmount: bigint;\n};\n\n/**\n * Swap parameters, either for an exact input or exact output swap.\n */\nexport type SwapParams = (ExactInParams | ExactOutParams) & {\n  /** The mint address of the token being swapped. */\n  mint: Address;\n};\n\n/**\n * Swap quote that corresponds to the type of swap being executed (either input or output swap).\n *\n * @template T - The type of swap (input or output).\n */\nexport type SwapQuote<T extends SwapParams> = T extends ExactInParams\n  ? ExactInSwapQuote\n  : ExactOutSwapQuote;\n\n/**\n * Instructions and quote for executing a swap.\n *\n * @template T - The type of swap (input or output).\n */\nexport type SwapInstructions<T extends SwapParams> = {\n  /** The list of instructions needed to perform the swap. */\n  instructions: IInstruction[];\n\n  /** The swap quote, which includes information about the amounts involved in the swap. */\n  quote: SwapQuote<T>;\n};\n\nfunction createUninitializedTickArray(\n  address: Address,\n  startTickIndex: number,\n  programAddress: Address,\n): Account<TickArrayFacade> {\n  return {\n    address,\n    data: {\n      startTickIndex,\n      ticks: Array(_TICK_ARRAY_SIZE()).fill({\n        initialized: false,\n        liquidityNet: 0n,\n        feeGrowthOutsideA: 0n,\n        feeGrowthOutsideB: 0n,\n        rewardGrowthsOutside: [0n, 0n, 0n],\n      }),\n    },\n    executable: false,\n    lamports: lamports(0n),\n    programAddress,\n  };\n}\n\nasync function fetchTickArrayOrDefault(\n  rpc: Rpc<GetMultipleAccountsApi>,\n  whirlpool: Account<Whirlpool>,\n): Promise<Account<TickArrayFacade>[]> {\n  const tickArrayStartIndex = getTickArrayStartTickIndex(\n    whirlpool.data.tickCurrentIndex,\n    whirlpool.data.tickSpacing,\n  );\n  const offset = whirlpool.data.tickSpacing * _TICK_ARRAY_SIZE();\n\n  const tickArrayIndexes = [\n    tickArrayStartIndex,\n    tickArrayStartIndex + offset,\n    tickArrayStartIndex + offset * 2,\n    tickArrayStartIndex - offset,\n    tickArrayStartIndex - offset * 2,\n  ];\n\n  const tickArrayAddresses = await Promise.all(\n    tickArrayIndexes.map((startIndex) =>\n      getTickArrayAddress(whirlpool.address, startIndex).then((x) => x[0]),\n    ),\n  );\n\n  const maybeTickArrays = await fetchAllMaybeTickArray(rpc, tickArrayAddresses);\n\n  const tickArrays: Account<TickArrayFacade>[] = [];\n\n  for (let i = 0; i < maybeTickArrays.length; i++) {\n    const maybeTickArray = maybeTickArrays[i];\n    if (maybeTickArray.exists) {\n      tickArrays.push(maybeTickArray);\n    } else {\n      tickArrays.push(\n        createUninitializedTickArray(\n          tickArrayAddresses[i],\n          tickArrayIndexes[i],\n          whirlpool.programAddress,\n        ),\n      );\n    }\n  }\n\n  return tickArrays;\n}\n\nfunction getSwapQuote<T extends SwapParams>(\n  params: T,\n  whirlpool: Whirlpool,\n  transferFeeA: TransferFee | undefined,\n  transferFeeB: TransferFee | undefined,\n  tickArrays: TickArrayFacade[],\n  specifiedTokenA: boolean,\n  slippageToleranceBps: number,\n): SwapQuote<T> {\n  if (\"inputAmount\" in params) {\n    return swapQuoteByInputToken(\n      params.inputAmount,\n      specifiedTokenA,\n      slippageToleranceBps,\n      whirlpool,\n      tickArrays,\n      transferFeeA,\n      transferFeeB,\n    ) as SwapQuote<T>;\n  }\n\n  return swapQuoteByOutputToken(\n    params.outputAmount,\n    specifiedTokenA,\n    slippageToleranceBps,\n    whirlpool,\n    tickArrays,\n    transferFeeA,\n    transferFeeB,\n  ) as SwapQuote<T>;\n}\n\n/**\n * Generates the instructions necessary to execute a token swap in an Orca Whirlpool.\n * It handles both exact input and exact output swaps, fetching the required accounts, tick arrays, and determining the swap quote.\n *\n * @template T - The type of swap (exact input or output).\n * @param {SolanaRpc} rpc - The Solana RPC client.\n * @param {T} params - The swap parameters, specifying either the input or output amount and the mint address of the token being swapped.\n * @param {Address} poolAddress - The address of the Whirlpool against which the swap will be made.\n * @param {number} [slippageToleranceBps=SLIPPAGE_TOLERANCE_BPS] - The maximum acceptable slippage tolerance for the swap, in basis points (BPS).\n * @param {TransactionSigner} [signer=FUNDER] - The wallet or signer executing the swap.\n * @returns {Promise<SwapInstructions<T>>} - A promise that resolves to an object containing the swap instructions and the swap quote.\n *\n * @example\n * import { swapInstructions } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner();\n * await devnetRpc.requestAirdrop(wallet.address, lamports(1000000000n)).send();\n *\n * const poolAddress = \"POOL_ADDRESS\";\n * const mintAddress = \"TOKEN_MINT\";\n * const inputAmount = 1_000_000n;\n *\n * const { instructions, quote } = await swapInstructions(\n *   devnetRpc,\n *   { inputAmount, mint: mintAddress },\n *   poolAddress,\n *   100,\n *   wallet\n * );\n */\nexport async function swapInstructions<T extends SwapParams>(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi\n  >,\n  params: T,\n  poolAddress: Address,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  signer: TransactionSigner = FUNDER,\n): Promise<SwapInstructions<T>> {\n  const whirlpool = await fetchWhirlpool(rpc, poolAddress);\n  const [tokenA, tokenB] = await fetchAllMint(rpc, [\n    whirlpool.data.tokenMintA,\n    whirlpool.data.tokenMintB,\n  ]);\n  const specifiedTokenA = params.mint === whirlpool.data.tokenMintA;\n  const specifiedInput = \"inputAmount\" in params;\n\n  const tickArrays = await fetchTickArrayOrDefault(rpc, whirlpool);\n\n  const oracleAddress = await getOracleAddress(whirlpool.address).then(\n    (x) => x[0],\n  );\n\n  const currentEpoch = await rpc.getEpochInfo().send();\n  const transferFeeA = getCurrentTransferFee(tokenA, currentEpoch.epoch);\n  const transferFeeB = getCurrentTransferFee(tokenB, currentEpoch.epoch);\n\n  const quote = getSwapQuote<T>(\n    params,\n    whirlpool.data,\n    transferFeeA,\n    transferFeeB,\n    tickArrays.map((x) => x.data),\n    specifiedTokenA,\n    slippageToleranceBps,\n  );\n  const maxInAmount = \"tokenIn\" in quote ? quote.tokenIn : quote.tokenMaxIn;\n  const aToB = specifiedTokenA === specifiedInput;\n\n  const { createInstructions, cleanupInstructions, tokenAccountAddresses } =\n    await prepareTokenAccountsInstructions(rpc, signer, {\n      [whirlpool.data.tokenMintA]: aToB ? maxInAmount : 0n,\n      [whirlpool.data.tokenMintB]: aToB ? 0n : maxInAmount,\n    });\n\n  const instructions: IInstruction[] = [];\n\n  instructions.push(...createInstructions);\n\n  const specifiedAmount =\n    \"inputAmount\" in params ? params.inputAmount : params.outputAmount;\n  const otherAmountThreshold =\n    \"tokenMaxIn\" in quote ? quote.tokenMaxIn : quote.tokenMinOut;\n\n  const swapInstruction = getSwapV2Instruction({\n    tokenProgramA: tokenA.programAddress,\n    tokenProgramB: tokenB.programAddress,\n    memoProgram: MEMO_PROGRAM_ADDRESS,\n    tokenAuthority: signer,\n    whirlpool: whirlpool.address,\n    tokenMintA: whirlpool.data.tokenMintA,\n    tokenMintB: whirlpool.data.tokenMintB,\n    tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n    tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n    tokenVaultA: whirlpool.data.tokenVaultA,\n    tokenVaultB: whirlpool.data.tokenVaultB,\n    tickArray0: tickArrays[0].address,\n    tickArray1: tickArrays[1].address,\n    tickArray2: tickArrays[2].address,\n    amount: specifiedAmount,\n    otherAmountThreshold,\n    sqrtPriceLimit: 0,\n    amountSpecifiedIsInput: specifiedInput,\n    aToB,\n    oracle: oracleAddress,\n    remainingAccountsInfo: {\n      slices: [\n        { accountsType: AccountsType.SupplementalTickArrays, length: 2 },\n      ],\n    },\n  });\n\n  swapInstruction.accounts.push(\n    { address: tickArrays[3].address, role: AccountRole.WRITABLE },\n    { address: tickArrays[4].address, role: AccountRole.WRITABLE },\n  );\n\n  instructions.push(swapInstruction);\n  instructions.push(...cleanupInstructions);\n\n  return {\n    quote,\n    instructions,\n  };\n}\n"],"mappings":"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","names":["x","getTickArrayAddress","getTickArrayStartTickIndex","findAssociatedTokenPda","TOKEN_PROGRAM_ADDRESS","fetchAllMint","getTokenSize","address","generateKeyPairSigner","address","fetchAllMint","generateKeyPairSigner","getTokenSize","lamports","fetchAllMint","assert","getTickArrayStartTickIndex","findAssociatedTokenPda","getTickArrayAddress","TOKEN_PROGRAM_ADDRESS","collectFeesQuote","collectRewardsQuote","getTickArrayStartTickIndex","getTickIndexInArray","fetchAllTickArray","fetchPosition","fetchWhirlpool","getCollectFeesV2Instruction","getCollectRewardV2Instruction","getPositionAddress","getTickArrayAddress","getUpdateFeesAndRewardsInstruction","findAssociatedTokenPda","fetchAllMaybeMint","MEMO_PROGRAM_ADDRESS","assert","getPositionAddress","fetchPosition","fetchWhirlpool","getTickArrayStartTickIndex","findAssociatedTokenPda","getTickArrayAddress","fetchAllTickArray","getTickIndexInArray","collectFeesQuote","collectRewardsQuote","getUpdateFeesAndRewardsInstruction","getCollectFeesV2Instruction","getCollectRewardV2Instruction","fetchPosition","fetchWhirlpool","getInitializeTickArrayInstruction","getPositionAddress","getTickArrayAddress","getTickArraySize","getFullRangeTickIndexes","getTickArrayStartTickIndex","address","generateKeyPairSigner","findAssociatedTokenPda","fetchAllMint","TOKEN_2022_PROGRAM_ADDRESS","MEMO_PROGRAM_ADDRESS","assert","getPositionAddress","fetchPosition","fetchWhirlpool","getTickArrayStartTickIndex","findAssociatedTokenPda","getTickArrayAddress","generateKeyPairSigner","getInitializeTickArrayInstruction","getTickArraySize","address","getFullRangeTickIndexes","getFeeTierAddress","getWhirlpoolAddress","getFeeTierAddress","getWhirlpoolAddress","x","getPositionAddress","TOKEN_PROGRAM_ADDRESS","TOKEN_2022_PROGRAM_ADDRESS","x","positions","lamports","getTickArrayStartTickIndex","fetchAllMaybeTickArray","fetchWhirlpool","getTickArrayAddress","MEMO_PROGRAM_ADDRESS","fetchAllMint","address","lamports","getTickArrayStartTickIndex","getTickArrayAddress","fetchAllMaybeTickArray","fetchWhirlpool"]}
// src/config.ts
import { getWhirlpoolsConfigExtensionAddress } from "@orca-so/whirlpools-client";
import { address, createNoopSigner } from "@solana/web3.js";
var DEFAULT_ADDRESS = address("11111111111111111111111111111111");
var DEFAULT_WHIRLPOOLS_CONFIG_ADDRESS = address(
  "2LecshUwdy9xi7meFgHtFJQNSKk4KdTrcpvaB56dP2NQ"
);
var DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = address(
  "777H5H3Tp9U11uRVRzFwM8BinfiakbaLT8vQpeuhvEiH"
);
var WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESS;
var WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;
async function setWhirlpoolsConfig(whirlpoolsConfigAddress) {
  WHIRLPOOLS_CONFIG_ADDRESS = whirlpoolsConfigAddress;
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = await getWhirlpoolsConfigExtensionAddress(whirlpoolsConfigAddress).then(
    (x) => x[0]
  );
}
var SPLASH_POOL_TICK_SPACING = 32896;
var DEFAULT_FUNDER = createNoopSigner(DEFAULT_ADDRESS);
var FUNDER = DEFAULT_FUNDER;
function setDefaultFunder(funder) {
  if (typeof funder === "string") {
    FUNDER = createNoopSigner(funder);
  } else {
    FUNDER = funder ?? createNoopSigner(DEFAULT_ADDRESS);
  }
}
var DEFAULT_SLIPPAGE_TOLERANCE_BPS = 100;
var SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;
function setDefaultSlippageToleranceBps(slippageToleranceBps) {
  SLIPPAGE_TOLERANCE_BPS = Math.floor(slippageToleranceBps);
}
var DEFAULT_SOL_WRAPPING_STRATEGY = "keypair";
var SOL_WRAPPING_STRATEGY = DEFAULT_SOL_WRAPPING_STRATEGY;
function setSolWrappingStrategy(strategy) {
  SOL_WRAPPING_STRATEGY = strategy;
}
function resetConfiguration() {
  WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESS;
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;
  FUNDER = DEFAULT_FUNDER;
  SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;
  SOL_WRAPPING_STRATEGY = DEFAULT_SOL_WRAPPING_STRATEGY;
}

// src/createPool.ts
import {
  getFeeTierAddress,
  getInitializePoolV2Instruction,
  getInitializeTickArrayInstruction,
  getTickArrayAddress,
  getTickArraySize,
  getTokenBadgeAddress,
  getWhirlpoolAddress,
  getWhirlpoolSize
} from "@orca-so/whirlpools-client";
import { generateKeyPairSigner } from "@solana/web3.js";
import {
  getFullRangeTickIndexes,
  getTickArrayStartTickIndex,
  priceToSqrtPrice,
  sqrtPriceToTickIndex
} from "@orca-so/whirlpools-core";
import { fetchAllMint, getTokenSize } from "@solana-program/token";
import assert from "assert";
function createSplashPoolInstructions(rpc, tokenMintA, tokenMintB, initialPrice = 1, funder = FUNDER) {
  return createConcentratedLiquidityPoolInstructions(
    rpc,
    tokenMintA,
    tokenMintB,
    SPLASH_POOL_TICK_SPACING,
    initialPrice,
    funder
  );
}
async function createConcentratedLiquidityPoolInstructions(rpc, tokenMintA, tokenMintB, tickSpacing, initialPrice = 1, funder = FUNDER) {
  assert(
    funder.address !== DEFAULT_ADDRESS,
    "Either supply a funder or set the default funder"
  );
  assert(
    Buffer.from(tokenMintA) < Buffer.from(tokenMintB),
    "Token order needs to be flipped to match the canonical ordering (i.e. sorted on the byte repr. of the mint pubkeys)"
  );
  const instructions = [];
  let stateSpace = 0;
  const [mintA, mintB] = await fetchAllMint(rpc, [tokenMintA, tokenMintB]);
  const decimalsA = mintA.data.decimals;
  const decimalsB = mintB.data.decimals;
  const tokenProgramA = mintA.programAddress;
  const tokenProgramB = mintB.programAddress;
  const initialSqrtPrice = priceToSqrtPrice(initialPrice, decimalsA, decimalsB);
  const [
    poolAddress,
    feeTier,
    tokenBadgeA,
    tokenBadgeB,
    tokenVaultA,
    tokenVaultB
  ] = await Promise.all([
    getWhirlpoolAddress(
      WHIRLPOOLS_CONFIG_ADDRESS,
      tokenMintA,
      tokenMintB,
      tickSpacing
    ).then((x) => x[0]),
    getFeeTierAddress(WHIRLPOOLS_CONFIG_ADDRESS, tickSpacing).then((x) => x[0]),
    getTokenBadgeAddress(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintA).then(
      (x) => x[0]
    ),
    getTokenBadgeAddress(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintB).then(
      (x) => x[0]
    ),
    generateKeyPairSigner(),
    generateKeyPairSigner()
  ]);
  instructions.push(
    getInitializePoolV2Instruction({
      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
      tokenMintA,
      tokenMintB,
      tokenBadgeA,
      tokenBadgeB,
      funder,
      whirlpool: poolAddress,
      tokenVaultA,
      tokenVaultB,
      tokenProgramA,
      tokenProgramB,
      feeTier,
      tickSpacing,
      initialSqrtPrice
    })
  );
  stateSpace += getTokenSize() * 2;
  stateSpace += getWhirlpoolSize();
  const fullRange = getFullRangeTickIndexes(tickSpacing);
  const lowerTickIndex = getTickArrayStartTickIndex(
    fullRange.tickLowerIndex,
    tickSpacing
  );
  const upperTickIndex = getTickArrayStartTickIndex(
    fullRange.tickUpperIndex,
    tickSpacing
  );
  const initialTickIndex = sqrtPriceToTickIndex(initialSqrtPrice);
  const currentTickIndex = getTickArrayStartTickIndex(
    initialTickIndex,
    tickSpacing
  );
  const tickArrayIndexes = Array.from(
    /* @__PURE__ */ new Set([lowerTickIndex, upperTickIndex, currentTickIndex])
  );
  const tickArrayAddresses = await Promise.all(
    tickArrayIndexes.map(
      (x) => getTickArrayAddress(poolAddress, x).then((x2) => x2[0])
    )
  );
  for (let i = 0; i < tickArrayIndexes.length; i++) {
    instructions.push(
      getInitializeTickArrayInstruction({
        whirlpool: poolAddress,
        funder,
        tickArray: tickArrayAddresses[i],
        startTickIndex: tickArrayIndexes[i]
      })
    );
    stateSpace += getTickArraySize();
  }
  const nonRefundableRent = await rpc.getMinimumBalanceForRentExemption(BigInt(stateSpace)).send();
  return {
    instructions,
    poolAddress,
    estInitializationCost: nonRefundableRent
  };
}

// src/decreaseLiquidity.ts
import {
  fetchAllTickArray,
  fetchPosition,
  fetchWhirlpool,
  getClosePositionInstruction,
  getClosePositionWithTokenExtensionsInstruction,
  getCollectFeesV2Instruction,
  getCollectRewardV2Instruction,
  getDecreaseLiquidityV2Instruction,
  getPositionAddress,
  getTickArrayAddress as getTickArrayAddress2,
  getUpdateFeesAndRewardsInstruction
} from "@orca-so/whirlpools-client";
import {
  getTickArrayStartTickIndex as getTickArrayStartTickIndex2,
  decreaseLiquidityQuote,
  decreaseLiquidityQuoteA,
  decreaseLiquidityQuoteB,
  collectFeesQuote,
  collectRewardsQuote,
  getTickIndexInArray
} from "@orca-so/whirlpools-core";
import {
  findAssociatedTokenPda as findAssociatedTokenPda2,
  TOKEN_PROGRAM_ADDRESS as TOKEN_PROGRAM_ADDRESS2
} from "@solana-program/token";

// src/token.ts
import {
  fetchAllMaybeToken,
  fetchAllMint as fetchAllMint2,
  findAssociatedTokenPda,
  getCloseAccountInstruction,
  getCreateAssociatedTokenInstruction,
  getInitializeAccount3Instruction,
  getSyncNativeInstruction,
  getTokenSize as getTokenSize2,
  TOKEN_PROGRAM_ADDRESS
} from "@solana-program/token";
import {
  address as address2,
  generateKeyPairSigner as generateKeyPairSigner2,
  getAddressDecoder,
  getAddressEncoder
} from "@solana/web3.js";
import {
  getCreateAccountInstruction,
  getCreateAccountWithSeedInstruction,
  getTransferSolInstruction
} from "@solana-program/system";
var NATIVE_MINT = address2(
  "So11111111111111111111111111111111111111112"
);
function mintFilter(x) {
  if (SOL_WRAPPING_STRATEGY === "none" || SOL_WRAPPING_STRATEGY === "ata") {
    return true;
  }
  return x != NATIVE_MINT;
}
async function prepareTokenAccountsInstructions(rpc, owner, spec) {
  const mintAddresses = Array.isArray(spec) ? spec : Object.keys(spec);
  const solMintIndex = mintAddresses.indexOf(NATIVE_MINT);
  const hasSolMint = solMintIndex !== -1;
  const mints = await fetchAllMint2(rpc, mintAddresses.filter(mintFilter));
  const tokenAddresses = await Promise.all(
    mints.map(
      (mint) => findAssociatedTokenPda({
        owner: owner.address,
        mint: mint.address,
        tokenProgram: mint.programAddress
      }).then((x) => x[0])
    )
  );
  const tokenAccounts = await fetchAllMaybeToken(rpc, tokenAddresses);
  const tokenAccountAddresses = {};
  const createInstructions = [];
  const cleanupInstructions = [];
  for (let i = 0; i < mints.length; i++) {
    const mint = mints[i];
    const tokenAccount = tokenAccounts[i];
    tokenAccountAddresses[mint.address] = tokenAccount.address;
    if (tokenAccount.exists) {
      continue;
    }
    createInstructions.push(
      getCreateAssociatedTokenInstruction({
        payer: owner,
        owner: owner.address,
        ata: tokenAccount.address,
        mint: mint.address,
        tokenProgram: mint.programAddress
      })
    );
  }
  if (hasSolMint && SOL_WRAPPING_STRATEGY === "keypair") {
    const keypair = await generateKeyPairSigner2();
    const space = getTokenSize2();
    const lamports3 = await rpc.getMinimumBalanceForRentExemption(BigInt(space)).send();
    createInstructions.push(
      getCreateAccountInstruction({
        payer: owner,
        newAccount: keypair,
        lamports: lamports3,
        space,
        programAddress: TOKEN_PROGRAM_ADDRESS
      }),
      getInitializeAccount3Instruction({
        account: keypair.address,
        mint: NATIVE_MINT,
        owner: owner.address
      })
    );
    cleanupInstructions.push(
      getCloseAccountInstruction({
        account: keypair.address,
        owner,
        destination: owner.address
      })
    );
    tokenAccountAddresses[NATIVE_MINT] = keypair.address;
  }
  if (hasSolMint && SOL_WRAPPING_STRATEGY === "seed") {
    const space = getTokenSize2();
    const amount = await rpc.getMinimumBalanceForRentExemption(BigInt(space)).send();
    const seed = Date.now().toString();
    const buffer = await crypto.subtle.digest(
      "SHA-256",
      Buffer.concat([
        Buffer.from(getAddressEncoder().encode(owner.address)),
        Buffer.from(seed),
        Buffer.from(getAddressEncoder().encode(TOKEN_PROGRAM_ADDRESS))
      ])
    );
    tokenAccountAddresses[NATIVE_MINT] = getAddressDecoder().decode(
      new Uint8Array(buffer)
    );
    createInstructions.push(
      getCreateAccountWithSeedInstruction({
        payer: owner,
        newAccount: tokenAccountAddresses[NATIVE_MINT],
        base: owner.address,
        baseAccount: owner,
        seed,
        space,
        amount,
        programAddress: TOKEN_PROGRAM_ADDRESS
      }),
      getInitializeAccount3Instruction({
        account: tokenAccountAddresses[NATIVE_MINT],
        mint: NATIVE_MINT,
        owner: owner.address
      })
    );
    cleanupInstructions.push(
      getCloseAccountInstruction({
        account: tokenAccountAddresses[NATIVE_MINT],
        owner,
        destination: owner.address
      })
    );
  }
  if (hasSolMint && SOL_WRAPPING_STRATEGY === "ata") {
    const account = tokenAccounts[solMintIndex];
    if (!account.exists) {
      cleanupInstructions.push(
        getCloseAccountInstruction({
          account: account.address,
          owner,
          destination: owner.address
        })
      );
    }
  }
  if (hasSolMint && !Array.isArray(spec) && spec[NATIVE_MINT] > 0 && SOL_WRAPPING_STRATEGY !== "none") {
    createInstructions.push(
      getTransferSolInstruction({
        source: owner,
        destination: tokenAccountAddresses[NATIVE_MINT],
        amount: spec[NATIVE_MINT]
      }),
      getSyncNativeInstruction({
        account: tokenAccountAddresses[NATIVE_MINT]
      })
    );
  }
  return {
    createInstructions,
    cleanupInstructions,
    tokenAccountAddresses
  };
}
function getCurrentTransferFee(mint, currentEpoch) {
  if (mint == null || "exists" in mint && !mint.exists || mint.data.extensions.__option === "None") {
    return void 0;
  }
  const feeConfig = mint.data.extensions.value.find(
    (x) => x.__kind === "TransferFeeConfig"
  );
  if (feeConfig == null) {
    return void 0;
  }
  const transferFee = currentEpoch >= feeConfig.newerTransferFee.epoch ? feeConfig.newerTransferFee : feeConfig.olderTransferFee;
  return {
    feeBps: transferFee.transferFeeBasisPoints,
    maxFee: transferFee.maximumFee
  };
}

// src/decreaseLiquidity.ts
import {
  fetchAllMint as fetchAllMint3,
  fetchAllMaybeMint,
  TOKEN_2022_PROGRAM_ADDRESS
} from "@solana-program/token-2022";
import { MEMO_PROGRAM_ADDRESS } from "@solana-program/memo";
import assert2 from "assert";
function getDecreaseLiquidityQuote(param, pool, tickRange, slippageToleranceBps, transferFeeA, transferFeeB) {
  if ("liquidity" in param) {
    return decreaseLiquidityQuote(
      param.liquidity,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else if ("tokenA" in param) {
    return decreaseLiquidityQuoteA(
      param.tokenA,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else {
    return decreaseLiquidityQuoteB(
      param.tokenB,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  }
}
async function decreaseLiquidityInstructions(rpc, positionMintAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  assert2(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply the authority or set the default funder"
  );
  const positionAddress = await getPositionAddress(positionMintAddress);
  const position = await fetchPosition(rpc, positionAddress[0]);
  const whirlpool = await fetchWhirlpool(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint] = await fetchAllMint3(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB,
    positionMintAddress
  ]);
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getDecreaseLiquidityQuote(
    param,
    whirlpool.data,
    position.data,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const instructions = [];
  const lowerTickArrayStartIndex = getTickArrayStartTickIndex2(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = getTickArrayStartTickIndex2(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, tickArrayLower, tickArrayUpper] = await Promise.all([
    findAssociatedTokenPda2({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    getTickArrayAddress2(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    getTickArrayAddress2(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  instructions.push(...createInstructions);
  instructions.push(
    getDecreaseLiquidityV2Instruction({
      whirlpool: whirlpool.address,
      positionAuthority: authority,
      position: position.address,
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      memoProgram: MEMO_PROGRAM_ADDRESS,
      tickArrayLower,
      tickArrayUpper,
      liquidityAmount: quote.liquidityDelta,
      tokenMinA: quote.tokenMinA,
      tokenMinB: quote.tokenMinB,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  return { quote, instructions };
}
async function closePositionInstructions(rpc, positionMintAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  assert2(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply an authority or set the default funder"
  );
  const positionAddress = await getPositionAddress(positionMintAddress);
  const position = await fetchPosition(rpc, positionAddress[0]);
  const whirlpool = await fetchWhirlpool(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint, ...rewardMints] = await fetchAllMaybeMint(
    rpc,
    [
      whirlpool.data.tokenMintA,
      whirlpool.data.tokenMintB,
      positionMintAddress,
      ...whirlpool.data.rewardInfos.map((x) => x.mint).filter((x) => x !== DEFAULT_ADDRESS)
    ]
  );
  assert2(mintA.exists, "Token A not found");
  assert2(mintB.exists, "Token B not found");
  assert2(positionMint.exists, "Position mint not found");
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getDecreaseLiquidityQuote(
    param,
    whirlpool.data,
    position.data,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const lowerTickArrayStartIndex = getTickArrayStartTickIndex2(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = getTickArrayStartTickIndex2(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] = await Promise.all([
    findAssociatedTokenPda2({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    getTickArrayAddress2(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    getTickArrayAddress2(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const [lowerTickArray, upperTickArray] = await fetchAllTickArray(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  const lowerTick = lowerTickArray.data.ticks[getTickIndexInArray(
    position.data.tickLowerIndex,
    lowerTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const upperTick = upperTickArray.data.ticks[getTickIndexInArray(
    position.data.tickUpperIndex,
    upperTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const feesQuote = collectFeesQuote(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    transferFeeA,
    transferFeeB
  );
  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1e3));
  const rewardsQuote = collectRewardsQuote(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    currentUnixTimestamp,
    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch)
  );
  const requiredMints = [];
  if (quote.liquidityDelta > 0n || feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    requiredMints.push(whirlpool.data.tokenMintA);
    requiredMints.push(whirlpool.data.tokenMintB);
  }
  if (rewardsQuote.rewards[0].rewardsOwed > 0n) {
    requiredMints.push(whirlpool.data.rewardInfos[0].mint);
  }
  if (rewardsQuote.rewards[1].rewardsOwed > 0n) {
    requiredMints.push(whirlpool.data.rewardInfos[1].mint);
  }
  if (rewardsQuote.rewards[2].rewardsOwed > 0n) {
    requiredMints.push(whirlpool.data.rewardInfos[2].mint);
  }
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, requiredMints);
  const instructions = [];
  instructions.push(...createInstructions);
  if (position.data.liquidity > 0n) {
    instructions.push(
      getUpdateFeesAndRewardsInstruction({
        whirlpool: whirlpool.address,
        position: positionAddress[0],
        tickArrayLower: lowerTickArrayAddress,
        tickArrayUpper: upperTickArrayAddress
      })
    );
  }
  if (quote.liquidityDelta > 0n) {
    instructions.push(
      getDecreaseLiquidityV2Instruction({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tickArrayLower: lowerTickArrayAddress,
        tickArrayUpper: upperTickArrayAddress,
        liquidityAmount: quote.liquidityDelta,
        tokenMinA: quote.tokenMinA,
        tokenMinB: quote.tokenMinB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    instructions.push(
      getCollectFeesV2Instruction({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {
      continue;
    }
    const rewardMint = rewardMints[i];
    assert2(rewardMint.exists, `Reward mint ${i} not found`);
    instructions.push(
      getCollectRewardV2Instruction({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],
        rewardVault: whirlpool.data.rewardInfos[i].vault,
        rewardIndex: i,
        rewardMint: rewardMint.address,
        rewardTokenProgram: rewardMint.programAddress,
        memoProgram: MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  switch (positionMint.programAddress) {
    case TOKEN_PROGRAM_ADDRESS2:
      instructions.push(
        getClosePositionInstruction({
          positionAuthority: authority,
          position: positionAddress[0],
          positionTokenAccount,
          positionMint: positionMintAddress,
          receiver: authority.address
        })
      );
      break;
    case TOKEN_2022_PROGRAM_ADDRESS:
      instructions.push(
        getClosePositionWithTokenExtensionsInstruction({
          positionAuthority: authority,
          position: positionAddress[0],
          positionTokenAccount,
          positionMint: positionMintAddress,
          receiver: authority.address,
          token2022Program: TOKEN_2022_PROGRAM_ADDRESS
        })
      );
      break;
    default:
      throw new Error("Invalid token program");
  }
  instructions.push(...cleanupInstructions);
  return {
    instructions,
    quote,
    feesQuote,
    rewardsQuote
  };
}

// src/harvest.ts
import {
  collectFeesQuote as collectFeesQuote2,
  collectRewardsQuote as collectRewardsQuote2,
  getTickArrayStartTickIndex as getTickArrayStartTickIndex3,
  getTickIndexInArray as getTickIndexInArray2
} from "@orca-so/whirlpools-core";
import {
  fetchAllTickArray as fetchAllTickArray2,
  fetchPosition as fetchPosition2,
  fetchWhirlpool as fetchWhirlpool2,
  getCollectFeesV2Instruction as getCollectFeesV2Instruction2,
  getCollectRewardV2Instruction as getCollectRewardV2Instruction2,
  getPositionAddress as getPositionAddress2,
  getTickArrayAddress as getTickArrayAddress3,
  getUpdateFeesAndRewardsInstruction as getUpdateFeesAndRewardsInstruction2
} from "@orca-so/whirlpools-client";
import { findAssociatedTokenPda as findAssociatedTokenPda3 } from "@solana-program/token";
import { fetchAllMaybeMint as fetchAllMaybeMint2 } from "@solana-program/token-2022";
import { MEMO_PROGRAM_ADDRESS as MEMO_PROGRAM_ADDRESS2 } from "@solana-program/memo";
import assert3 from "assert";
async function harvestPositionInstructions(rpc, positionMintAddress, authority = FUNDER) {
  assert3(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply an authority or set the default funder"
  );
  const currentEpoch = await rpc.getEpochInfo().send();
  const positionAddress = await getPositionAddress2(positionMintAddress);
  const position = await fetchPosition2(rpc, positionAddress[0]);
  const whirlpool = await fetchWhirlpool2(rpc, position.data.whirlpool);
  const [mintA, mintB, positionMint, ...rewardMints] = await fetchAllMaybeMint2(
    rpc,
    [
      whirlpool.data.tokenMintA,
      whirlpool.data.tokenMintB,
      positionMintAddress,
      ...whirlpool.data.rewardInfos.map((x) => x.mint).filter((x) => x !== DEFAULT_ADDRESS)
    ]
  );
  assert3(mintA.exists, "Token A not found");
  assert3(mintB.exists, "Token B not found");
  assert3(positionMint.exists, "Position mint not found");
  const lowerTickArrayStartIndex = getTickArrayStartTickIndex3(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = getTickArrayStartTickIndex3(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] = await Promise.all([
    findAssociatedTokenPda3({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    getTickArrayAddress3(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    getTickArrayAddress3(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const [lowerTickArray, upperTickArray] = await fetchAllTickArray2(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  const lowerTick = lowerTickArray.data.ticks[getTickIndexInArray2(
    position.data.tickLowerIndex,
    lowerTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const upperTick = upperTickArray.data.ticks[getTickIndexInArray2(
    position.data.tickUpperIndex,
    upperTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const feesQuote = collectFeesQuote2(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    getCurrentTransferFee(mintA, currentEpoch.epoch),
    getCurrentTransferFee(mintB, currentEpoch.epoch)
  );
  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1e3));
  const rewardsQuote = collectRewardsQuote2(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    currentUnixTimestamp,
    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch)
  );
  const requiredMints = [];
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    requiredMints.push(whirlpool.data.tokenMintA);
    requiredMints.push(whirlpool.data.tokenMintB);
  }
  if (rewardsQuote.rewards[0].rewardsOwed > 0n) {
    requiredMints.push(whirlpool.data.rewardInfos[0].mint);
  }
  if (rewardsQuote.rewards[1].rewardsOwed > 0n) {
    requiredMints.push(whirlpool.data.rewardInfos[1].mint);
  }
  if (rewardsQuote.rewards[2].rewardsOwed > 0n) {
    requiredMints.push(whirlpool.data.rewardInfos[2].mint);
  }
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, requiredMints);
  const instructions = [];
  instructions.push(...createInstructions);
  if (position.data.liquidity > 0n) {
    instructions.push(
      getUpdateFeesAndRewardsInstruction2({
        whirlpool: whirlpool.address,
        position: positionAddress[0],
        tickArrayLower: lowerTickArrayAddress,
        tickArrayUpper: upperTickArrayAddress
      })
    );
  }
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    instructions.push(
      getCollectFeesV2Instruction2({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: MEMO_PROGRAM_ADDRESS2,
        remainingAccountsInfo: null
      })
    );
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {
      continue;
    }
    const rewardMint = rewardMints[i];
    assert3(rewardMint.exists, `Reward mint ${i} not found`);
    instructions.push(
      getCollectRewardV2Instruction2({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],
        rewardVault: whirlpool.data.rewardInfos[i].vault,
        rewardIndex: i,
        rewardMint: rewardMint.address,
        rewardTokenProgram: rewardMint.programAddress,
        memoProgram: MEMO_PROGRAM_ADDRESS2,
        remainingAccountsInfo: null
      })
    );
  }
  instructions.push(...cleanupInstructions);
  return {
    feesQuote,
    rewardsQuote,
    instructions
  };
}

// src/increaseLiquidity.ts
import {
  fetchAllMaybeTickArray,
  fetchPosition as fetchPosition3,
  fetchWhirlpool as fetchWhirlpool3,
  getIncreaseLiquidityV2Instruction,
  getInitializeTickArrayInstruction as getInitializeTickArrayInstruction2,
  getOpenPositionWithTokenExtensionsInstruction,
  getPositionAddress as getPositionAddress3,
  getTickArrayAddress as getTickArrayAddress4,
  getTickArraySize as getTickArraySize2
} from "@orca-so/whirlpools-client";
import {
  getFullRangeTickIndexes as getFullRangeTickIndexes2,
  getTickArrayStartTickIndex as getTickArrayStartTickIndex4,
  increaseLiquidityQuote,
  increaseLiquidityQuoteA,
  increaseLiquidityQuoteB,
  priceToTickIndex,
  getInitializableTickIndex,
  orderTickIndexes
} from "@orca-so/whirlpools-core";
import { address as address3, generateKeyPairSigner as generateKeyPairSigner3, lamports } from "@solana/web3.js";
import {
  ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
  findAssociatedTokenPda as findAssociatedTokenPda4
} from "@solana-program/token";
import {
  fetchAllMint as fetchAllMint4,
  TOKEN_2022_PROGRAM_ADDRESS as TOKEN_2022_PROGRAM_ADDRESS2
} from "@solana-program/token-2022";
import { MEMO_PROGRAM_ADDRESS as MEMO_PROGRAM_ADDRESS3 } from "@solana-program/memo";
import assert4 from "assert";
function getIncreaseLiquidityQuote(param, pool, tickRange, slippageToleranceBps, transferFeeA, transferFeeB) {
  if ("liquidity" in param) {
    return increaseLiquidityQuote(
      param.liquidity,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else if ("tokenA" in param) {
    return increaseLiquidityQuoteA(
      param.tokenA,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else {
    return increaseLiquidityQuoteB(
      param.tokenB,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  }
}
async function increaseLiquidityInstructions(rpc, positionMintAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  assert4(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply the authority or set the default funder"
  );
  const positionAddress = await getPositionAddress3(positionMintAddress);
  const position = await fetchPosition3(rpc, positionAddress[0]);
  const whirlpool = await fetchWhirlpool3(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint] = await fetchAllMint4(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB,
    positionMintAddress
  ]);
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getIncreaseLiquidityQuote(
    param,
    whirlpool.data,
    position.data,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const instructions = [];
  const lowerTickArrayStartIndex = getTickArrayStartTickIndex4(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = getTickArrayStartTickIndex4(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, tickArrayLower, tickArrayUpper] = await Promise.all([
    findAssociatedTokenPda4({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    getTickArrayAddress4(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    getTickArrayAddress4(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, {
    [whirlpool.data.tokenMintA]: quote.tokenMaxA,
    [whirlpool.data.tokenMintB]: quote.tokenMaxB
  });
  instructions.push(...createInstructions);
  instructions.push(
    getIncreaseLiquidityV2Instruction({
      whirlpool: whirlpool.address,
      positionAuthority: authority,
      position: position.address,
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      tickArrayLower,
      tickArrayUpper,
      liquidityAmount: quote.liquidityDelta,
      tokenMaxA: quote.tokenMaxA,
      tokenMaxB: quote.tokenMaxB,
      memoProgram: MEMO_PROGRAM_ADDRESS3,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  return {
    quote,
    instructions,
    positionMint: positionMintAddress,
    initializationCost: lamports(0n)
  };
}
async function internalOpenPositionInstructions(rpc, whirlpool, param, lowerTickIndex, upperTickIndex, mintA, mintB, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  assert4(
    funder.address !== DEFAULT_ADDRESS,
    "Either supply a funder or set the default funder"
  );
  const instructions = [];
  let nonReclaimableStateSpace = 0;
  const initializableLowerTickIndex = getInitializableTickIndex(
    lowerTickIndex,
    whirlpool.data.tickSpacing,
    false
  );
  const initializableUpperTickIndex = getInitializableTickIndex(
    upperTickIndex,
    whirlpool.data.tickSpacing,
    true
  );
  const tickRange = orderTickIndexes(
    initializableLowerTickIndex,
    initializableUpperTickIndex
  );
  const currentEpoch = await rpc.getEpochInfo().send();
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getIncreaseLiquidityQuote(
    param,
    whirlpool.data,
    tickRange,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const positionMint = await generateKeyPairSigner3();
  const lowerTickArrayIndex = getTickArrayStartTickIndex4(
    tickRange.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayIndex = getTickArrayStartTickIndex4(
    tickRange.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [
    positionAddress,
    positionTokenAccount,
    lowerTickArrayAddress,
    upperTickArrayAddress
  ] = await Promise.all([
    getPositionAddress3(positionMint.address),
    findAssociatedTokenPda4({
      owner: funder.address,
      mint: positionMint.address,
      tokenProgram: TOKEN_2022_PROGRAM_ADDRESS2
    }).then((x) => x[0]),
    getTickArrayAddress4(whirlpool.address, lowerTickArrayIndex).then(
      (x) => x[0]
    ),
    getTickArrayAddress4(whirlpool.address, upperTickArrayIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, funder, {
    [whirlpool.data.tokenMintA]: quote.tokenMaxA,
    [whirlpool.data.tokenMintB]: quote.tokenMaxB
  });
  instructions.push(...createInstructions);
  const [lowerTickArray, upperTickArray] = await fetchAllMaybeTickArray(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  if (!lowerTickArray.exists) {
    instructions.push(
      getInitializeTickArrayInstruction2({
        whirlpool: whirlpool.address,
        funder,
        tickArray: lowerTickArrayAddress,
        startTickIndex: lowerTickIndex
      })
    );
    nonReclaimableStateSpace += getTickArraySize2();
  }
  if (!upperTickArray.exists && lowerTickArrayIndex !== upperTickArrayIndex) {
    instructions.push(
      getInitializeTickArrayInstruction2({
        whirlpool: whirlpool.address,
        funder,
        tickArray: upperTickArrayAddress,
        startTickIndex: upperTickIndex
      })
    );
    nonReclaimableStateSpace += getTickArraySize2();
  }
  instructions.push(
    getOpenPositionWithTokenExtensionsInstruction({
      funder,
      owner: funder.address,
      position: positionAddress[0],
      positionMint,
      positionTokenAccount,
      whirlpool: whirlpool.address,
      associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
      tickLowerIndex: tickRange.tickLowerIndex,
      tickUpperIndex: tickRange.tickUpperIndex,
      token2022Program: TOKEN_2022_PROGRAM_ADDRESS2,
      metadataUpdateAuth: address3(
        "3axbTs2z5GBy6usVbNVoqEgZMng3vZvMnAoX29BFfwhr"
      ),
      withTokenMetadataExtension: true
    })
  );
  instructions.push(
    getIncreaseLiquidityV2Instruction({
      whirlpool: whirlpool.address,
      positionAuthority: funder,
      position: positionAddress[0],
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      tickArrayLower: lowerTickArrayAddress,
      tickArrayUpper: upperTickArrayAddress,
      liquidityAmount: quote.liquidityDelta,
      tokenMaxA: quote.tokenMaxA,
      tokenMaxB: quote.tokenMaxB,
      memoProgram: MEMO_PROGRAM_ADDRESS3,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  let nonRefundableRent = lamports(0n);
  if (nonReclaimableStateSpace > 0) {
    nonRefundableRent = await rpc.getMinimumBalanceForRentExemption(BigInt(nonReclaimableStateSpace)).send();
  }
  return {
    instructions,
    quote,
    positionMint: positionMint.address,
    initializationCost: nonRefundableRent
  };
}
async function openFullRangePositionInstructions(rpc, poolAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  const whirlpool = await fetchWhirlpool3(rpc, poolAddress);
  const tickRange = getFullRangeTickIndexes2(whirlpool.data.tickSpacing);
  const [mintA, mintB] = await fetchAllMint4(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  return internalOpenPositionInstructions(
    rpc,
    whirlpool,
    param,
    tickRange.tickLowerIndex,
    tickRange.tickUpperIndex,
    mintA,
    mintB,
    slippageToleranceBps,
    funder
  );
}
async function openPositionInstructions(rpc, poolAddress, param, lowerPrice, upperPrice, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  const whirlpool = await fetchWhirlpool3(rpc, poolAddress);
  assert4(
    whirlpool.data.tickSpacing !== SPLASH_POOL_TICK_SPACING,
    "Splash pools only support full range positions"
  );
  const [mintA, mintB] = await fetchAllMint4(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  const decimalsA = mintA.data.decimals;
  const decimalsB = mintB.data.decimals;
  const lowerTickIndex = priceToTickIndex(lowerPrice, decimalsA, decimalsB);
  const lowerInitializableTickIndex = getInitializableTickIndex(
    lowerTickIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickIndex = priceToTickIndex(upperPrice, decimalsA, decimalsB);
  const upperInitializableTickIndex = getInitializableTickIndex(
    upperTickIndex,
    whirlpool.data.tickSpacing
  );
  return internalOpenPositionInstructions(
    rpc,
    whirlpool,
    param,
    lowerInitializableTickIndex,
    upperInitializableTickIndex,
    mintA,
    mintB,
    slippageToleranceBps,
    funder
  );
}

// src/pool.ts
import {
  getFeeTierAddress as getFeeTierAddress2,
  getWhirlpoolAddress as getWhirlpoolAddress2,
  fetchWhirlpoolsConfig,
  fetchFeeTier,
  fetchMaybeWhirlpool,
  fetchAllMaybeWhirlpool,
  fetchAllFeeTierWithFilter,
  feeTierWhirlpoolsConfigFilter
} from "@orca-so/whirlpools-client";
async function fetchSplashPool(rpc, tokenMintOne, tokenMintTwo) {
  return fetchConcentratedLiquidityPool(
    rpc,
    tokenMintOne,
    tokenMintTwo,
    SPLASH_POOL_TICK_SPACING
  );
}
async function fetchConcentratedLiquidityPool(rpc, tokenMintOne, tokenMintTwo, tickSpacing) {
  const [tokenMintA, tokenMintB] = Buffer.from(tokenMintOne) < Buffer.from(tokenMintTwo) ? [tokenMintOne, tokenMintTwo] : [tokenMintTwo, tokenMintOne];
  const feeTierAddress = await getFeeTierAddress2(
    WHIRLPOOLS_CONFIG_ADDRESS,
    tickSpacing
  ).then((x) => x[0]);
  const poolAddress = await getWhirlpoolAddress2(
    WHIRLPOOLS_CONFIG_ADDRESS,
    tokenMintA,
    tokenMintB,
    tickSpacing
  ).then((x) => x[0]);
  const [configAccount, feeTierAccount, poolAccount] = await Promise.all([
    fetchWhirlpoolsConfig(rpc, WHIRLPOOLS_CONFIG_ADDRESS),
    fetchFeeTier(rpc, feeTierAddress),
    fetchMaybeWhirlpool(rpc, poolAddress)
  ]);
  if (poolAccount.exists) {
    return {
      initialized: true,
      address: poolAddress,
      ...poolAccount.data
    };
  } else {
    return {
      initialized: false,
      address: poolAddress,
      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
      tickSpacing,
      feeRate: feeTierAccount.data.defaultFeeRate,
      protocolFeeRate: configAccount.data.defaultProtocolFeeRate,
      tokenMintA,
      tokenMintB
    };
  }
}
async function fetchWhirlpools(rpc, tokenMintOne, tokenMintTwo) {
  const [tokenMintA, tokenMintB] = Buffer.from(tokenMintOne) < Buffer.from(tokenMintTwo) ? [tokenMintOne, tokenMintTwo] : [tokenMintTwo, tokenMintOne];
  const feeTierAccounts = await fetchAllFeeTierWithFilter(
    rpc,
    feeTierWhirlpoolsConfigFilter(WHIRLPOOLS_CONFIG_ADDRESS)
  );
  const supportedTickSpacings = feeTierAccounts.map((x) => x.data.tickSpacing);
  const poolAddresses = await Promise.all(
    supportedTickSpacings.map(
      (x) => getWhirlpoolAddress2(
        WHIRLPOOLS_CONFIG_ADDRESS,
        tokenMintA,
        tokenMintB,
        x
      ).then((x2) => x2[0])
    )
  );
  const [configAccount, poolAccounts] = await Promise.all([
    fetchWhirlpoolsConfig(rpc, WHIRLPOOLS_CONFIG_ADDRESS),
    fetchAllMaybeWhirlpool(rpc, poolAddresses)
  ]);
  const pools = [];
  for (let i = 0; i < supportedTickSpacings.length; i++) {
    const tickSpacing = supportedTickSpacings[i];
    const feeTierAccount = feeTierAccounts[i];
    const poolAccount = poolAccounts[i];
    const poolAddress = poolAddresses[i];
    if (poolAccount.exists) {
      pools.push({
        initialized: true,
        address: poolAddress,
        ...poolAccount.data
      });
    } else {
      pools.push({
        initialized: false,
        address: poolAddress,
        whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
        tickSpacing,
        feeRate: feeTierAccount.data.defaultFeeRate,
        protocolFeeRate: configAccount.data.defaultProtocolFeeRate,
        tokenMintA,
        tokenMintB
      });
    }
  }
  return pools;
}

// src/position.ts
import {
  fetchAllMaybePosition,
  fetchAllMaybePositionBundle,
  fetchAllPosition,
  getBundledPositionAddress,
  getPositionAddress as getPositionAddress4,
  getPositionBundleAddress
} from "@orca-so/whirlpools-client";
import { _POSITION_BUNDLE_SIZE } from "@orca-so/whirlpools-core";
import { getTokenDecoder, TOKEN_PROGRAM_ADDRESS as TOKEN_PROGRAM_ADDRESS3 } from "@solana-program/token";
import { TOKEN_2022_PROGRAM_ADDRESS as TOKEN_2022_PROGRAM_ADDRESS3 } from "@solana-program/token-2022";
import { getBase58Encoder } from "@solana/web3.js";
function getPositionInBundleAddresses(positionBundle) {
  const buffer = Buffer.from(positionBundle.positionBitmap);
  const positions = [];
  for (let i = 0; i < _POSITION_BUNDLE_SIZE(); i++) {
    const byteIndex = Math.floor(i / 8);
    const bitIndex = i % 8;
    if (buffer[byteIndex] & 1 << bitIndex) {
      positions.push(
        getBundledPositionAddress(positionBundle.positionBundleMint, i).then(
          (x) => x[0]
        )
      );
    }
  }
  return positions;
}
async function fetchPositionsForOwner(rpc, owner) {
  const [tokenAccounts, token2022Accounts] = await Promise.all([
    rpc.getTokenAccountsByOwner(owner, { programId: TOKEN_PROGRAM_ADDRESS3 }).send(),
    rpc.getTokenAccountsByOwner(owner, { programId: TOKEN_2022_PROGRAM_ADDRESS3 }).send()
  ]);
  const encoder = getBase58Encoder();
  const decoder = getTokenDecoder();
  const potentialTokens = [...tokenAccounts.value, ...token2022Accounts.value].map((x) => ({
    ...decoder.decode(encoder.encode(x.account.data)),
    owner: x.account.owner
  })).filter((x) => x.amount === 1n);
  const positionAddresses = await Promise.all(
    potentialTokens.map((x) => getPositionAddress4(x.mint).then((x2) => x2[0]))
  );
  const positionBundleAddresses = await Promise.all(
    potentialTokens.map(
      (x) => getPositionBundleAddress(x.mint).then((x2) => x2[0])
    )
  );
  const [positions, positionBundles] = await Promise.all([
    fetchAllMaybePosition(rpc, positionAddresses),
    fetchAllMaybePositionBundle(rpc, positionBundleAddresses)
  ]);
  const bundledPositionAddresses = await Promise.all(
    positionBundles.filter((x) => x.exists).flatMap((x) => getPositionInBundleAddresses(x.data))
  );
  const bundledPositions = await fetchAllPosition(
    rpc,
    bundledPositionAddresses
  );
  const bundledPositionMap = bundledPositions.reduce((acc, x) => {
    const current = acc.get(x.data.positionMint) ?? [];
    return acc.set(x.data.positionMint, [...current, x]);
  }, /* @__PURE__ */ new Map());
  const positionsOrBundles = [];
  for (let i = 0; i < potentialTokens.length; i++) {
    const position = positions[i];
    const positionBundle = positionBundles[i];
    const token = potentialTokens[i];
    if (position.exists) {
      positionsOrBundles.push({
        ...position,
        tokenProgram: token.owner,
        isPositionBundle: false
      });
    }
    if (positionBundle.exists) {
      const positions2 = bundledPositionMap.get(positionBundle.data.positionBundleMint) ?? [];
      positionsOrBundles.push({
        ...positionBundle,
        positions: positions2,
        tokenProgram: token.owner,
        isPositionBundle: true
      });
    }
  }
  return positionsOrBundles;
}

// src/swap.ts
import { AccountRole, lamports as lamports2 } from "@solana/web3.js";
import {
  _TICK_ARRAY_SIZE,
  getTickArrayStartTickIndex as getTickArrayStartTickIndex5,
  swapQuoteByInputToken,
  swapQuoteByOutputToken
} from "@orca-so/whirlpools-core";
import {
  AccountsType,
  fetchAllMaybeTickArray as fetchAllMaybeTickArray2,
  fetchWhirlpool as fetchWhirlpool4,
  getOracleAddress,
  getSwapV2Instruction,
  getTickArrayAddress as getTickArrayAddress5
} from "@orca-so/whirlpools-client";
import { MEMO_PROGRAM_ADDRESS as MEMO_PROGRAM_ADDRESS4 } from "@solana-program/memo";
import { fetchAllMint as fetchAllMint5 } from "@solana-program/token-2022";
function createUninitializedTickArray(address4, startTickIndex, programAddress) {
  return {
    address: address4,
    data: {
      startTickIndex,
      ticks: Array(_TICK_ARRAY_SIZE()).fill({
        initialized: false,
        liquidityNet: 0n,
        feeGrowthOutsideA: 0n,
        feeGrowthOutsideB: 0n,
        rewardGrowthsOutside: [0n, 0n, 0n]
      })
    },
    executable: false,
    lamports: lamports2(0n),
    programAddress
  };
}
async function fetchTickArrayOrDefault(rpc, whirlpool) {
  const tickArrayStartIndex = getTickArrayStartTickIndex5(
    whirlpool.data.tickCurrentIndex,
    whirlpool.data.tickSpacing
  );
  const offset = whirlpool.data.tickSpacing * _TICK_ARRAY_SIZE();
  const tickArrayIndexes = [
    tickArrayStartIndex,
    tickArrayStartIndex + offset,
    tickArrayStartIndex + offset * 2,
    tickArrayStartIndex - offset,
    tickArrayStartIndex - offset * 2
  ];
  const tickArrayAddresses = await Promise.all(
    tickArrayIndexes.map(
      (startIndex) => getTickArrayAddress5(whirlpool.address, startIndex).then((x) => x[0])
    )
  );
  const maybeTickArrays = await fetchAllMaybeTickArray2(rpc, tickArrayAddresses);
  const tickArrays = [];
  for (let i = 0; i < maybeTickArrays.length; i++) {
    const maybeTickArray = maybeTickArrays[i];
    if (maybeTickArray.exists) {
      tickArrays.push(maybeTickArray);
    } else {
      tickArrays.push(
        createUninitializedTickArray(
          tickArrayAddresses[i],
          tickArrayIndexes[i],
          whirlpool.programAddress
        )
      );
    }
  }
  return tickArrays;
}
function getSwapQuote(params, whirlpool, transferFeeA, transferFeeB, tickArrays, specifiedTokenA, slippageToleranceBps) {
  if ("inputAmount" in params) {
    return swapQuoteByInputToken(
      params.inputAmount,
      specifiedTokenA,
      slippageToleranceBps,
      whirlpool,
      tickArrays,
      transferFeeA,
      transferFeeB
    );
  }
  return swapQuoteByOutputToken(
    params.outputAmount,
    specifiedTokenA,
    slippageToleranceBps,
    whirlpool,
    tickArrays,
    transferFeeA,
    transferFeeB
  );
}
async function swapInstructions(rpc, params, poolAddress, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, signer = FUNDER) {
  const whirlpool = await fetchWhirlpool4(rpc, poolAddress);
  const [tokenA, tokenB] = await fetchAllMint5(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  const specifiedTokenA = params.mint === whirlpool.data.tokenMintA;
  const specifiedInput = "inputAmount" in params;
  const tickArrays = await fetchTickArrayOrDefault(rpc, whirlpool);
  const oracleAddress = await getOracleAddress(whirlpool.address).then(
    (x) => x[0]
  );
  const currentEpoch = await rpc.getEpochInfo().send();
  const transferFeeA = getCurrentTransferFee(tokenA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(tokenB, currentEpoch.epoch);
  const quote = getSwapQuote(
    params,
    whirlpool.data,
    transferFeeA,
    transferFeeB,
    tickArrays.map((x) => x.data),
    specifiedTokenA,
    slippageToleranceBps
  );
  const maxInAmount = "tokenIn" in quote ? quote.tokenIn : quote.tokenMaxIn;
  const aToB = specifiedTokenA === specifiedInput;
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, signer, {
    [whirlpool.data.tokenMintA]: aToB ? maxInAmount : 0n,
    [whirlpool.data.tokenMintB]: aToB ? 0n : maxInAmount
  });
  const instructions = [];
  instructions.push(...createInstructions);
  const specifiedAmount = "inputAmount" in params ? params.inputAmount : params.outputAmount;
  const otherAmountThreshold = "tokenMaxIn" in quote ? quote.tokenMaxIn : quote.tokenMinOut;
  const swapInstruction = getSwapV2Instruction({
    tokenProgramA: tokenA.programAddress,
    tokenProgramB: tokenB.programAddress,
    memoProgram: MEMO_PROGRAM_ADDRESS4,
    tokenAuthority: signer,
    whirlpool: whirlpool.address,
    tokenMintA: whirlpool.data.tokenMintA,
    tokenMintB: whirlpool.data.tokenMintB,
    tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
    tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
    tokenVaultA: whirlpool.data.tokenVaultA,
    tokenVaultB: whirlpool.data.tokenVaultB,
    tickArray0: tickArrays[0].address,
    tickArray1: tickArrays[1].address,
    tickArray2: tickArrays[2].address,
    amount: specifiedAmount,
    otherAmountThreshold,
    sqrtPriceLimit: 0,
    amountSpecifiedIsInput: specifiedInput,
    aToB,
    oracle: oracleAddress,
    remainingAccountsInfo: {
      slices: [
        { accountsType: AccountsType.SupplementalTickArrays, length: 2 }
      ]
    }
  });
  swapInstruction.accounts.push(
    { address: tickArrays[3].address, role: AccountRole.WRITABLE },
    { address: tickArrays[4].address, role: AccountRole.WRITABLE }
  );
  instructions.push(swapInstruction);
  instructions.push(...cleanupInstructions);
  return {
    quote,
    instructions
  };
}
export {
  DEFAULT_ADDRESS,
  DEFAULT_FUNDER,
  DEFAULT_SLIPPAGE_TOLERANCE_BPS,
  DEFAULT_SOL_WRAPPING_STRATEGY,
  DEFAULT_WHIRLPOOLS_CONFIG_ADDRESS,
  DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  FUNDER,
  SLIPPAGE_TOLERANCE_BPS,
  SOL_WRAPPING_STRATEGY,
  SPLASH_POOL_TICK_SPACING,
  WHIRLPOOLS_CONFIG_ADDRESS,
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  closePositionInstructions,
  createConcentratedLiquidityPoolInstructions,
  createSplashPoolInstructions,
  decreaseLiquidityInstructions,
  fetchConcentratedLiquidityPool,
  fetchPositionsForOwner,
  fetchSplashPool,
  fetchWhirlpools,
  harvestPositionInstructions,
  increaseLiquidityInstructions,
  openFullRangePositionInstructions,
  openPositionInstructions,
  resetConfiguration,
  setDefaultFunder,
  setDefaultSlippageToleranceBps,
  setSolWrappingStrategy,
  setWhirlpoolsConfig,
  swapInstructions
};
//# sourceMappingURL=index.js.map